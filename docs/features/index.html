<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>tsflex.features API documentation</title>
<meta name="description" content="Feature extraction submodule ‚Ä¶" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/foundation.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#ebf3ff}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#edfcf4}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script>
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
ga('create', 'G-C88NHWRRP8', 'auto'); ga('send', 'pageview');
</script><script async src='https://www.google-analytics.com/analytics.js'></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
<link rel="icon" href="https://media.discordapp.net/attachments/372491075153166338/852906324417445908/icon.png">
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>tsflex.features</code></h1>
</header>
<section id="section-intro">
<p>Feature extraction submodule.</p>
<h1 id="feature-extraction-guide">Feature extraction guide</h1>
<p>The following sections will explain the feature extraction module in detail.</p>
<p><a href="#header-submodules"><strong>Jump to API reference</strong></a></p>
<p><br></p>
<h2 id="working-example">Working example ‚úÖ</h2>
<p><em>tsflex</em> is built to be intuitive, so we encourage you to copy-paste this code and toy with some parameters! <br></p>
<p>This executable example creates a feature-collection that contains 2 features (skewness and minimum). <br>
<strong>Note</strong>: we do not make any assumptions about the sampling rate of the time-series data.</p>
<pre><code class="language-python">import pandas as pd; import scipy.stats as ss; import numpy as np
from tsflex.features import FeatureDescriptor, FeatureCollection, NumpyFuncWrapper

# 1. -------- Get your time-indexed data --------
# Data contains 1 column; [&quot;TMP&quot;]
url = &quot;https://github.com/predict-idlab/tsflex/raw/main/examples/data/empatica/&quot;
data = pd.read_parquet(url + &quot;tmp.parquet&quot;).set_index(&quot;timestamp&quot;)

# 2 -------- Construct your feature collection --------
fc = FeatureCollection(
    feature_descriptors=[
        FeatureDescriptor(
            function=NumpyFuncWrapper(func=ss.skew, output_names=&quot;skew&quot;),
            series_name=&quot;TMP&quot;, 
            window=&quot;5min&quot;, stride=&quot;2.5min&quot;,
        )
    ]
)
# -- 2.1. Add features to your feature collection
fc.add(FeatureDescriptor(np.min, &quot;TMP&quot;, '2.5min', '2.5min'))

# 3 -------- Calculate features --------
fc.calculate(data=data, return_df=True)
# which outputs:
</code></pre>
<table>
<thead>
<tr>
<th align="left">timestamp</th>
<th align="right">TMP__amin__w=1m_s=30s</th>
<th align="right">TMP__skew__w=2m_s=1m</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">2017-06-13 14:23:13+02:00</td>
<td align="right">27.37</td>
<td align="right">nan</td>
</tr>
<tr>
<td align="left">2017-06-13 14:23:43+02:00</td>
<td align="right">27.37</td>
<td align="right">nan</td>
</tr>
<tr>
<td align="left">2017-06-13 14:24:13+02:00</td>
<td align="right">27.43</td>
<td align="right">10.8159</td>
</tr>
<tr>
<td align="left">2017-06-13 14:24:43+02:00</td>
<td align="right">27.81</td>
<td align="right">nan</td>
</tr>
<tr>
<td align="left">2017-06-13 14:25:13+02:00</td>
<td align="right">28.23</td>
<td align="right">-0.0327893</td>
</tr>
<tr>
<td align="left">&hellip;</td>
<td align="right">&hellip;</td>
<td align="right">&hellip;</td>
</tr>
<tr>
<td align="left"><br></td>
<td align="right"></td>
<td align="right"></td>
</tr>
</tbody>
</table>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>More advanced feature-extraction examples can be found <a href="https://github.com/predict-idlab/tsflex/tree/main/examples">in these example notebooks</a></p>
</div>
<p><br></p>
<h2 id="getting-started">Getting started üöÄ</h2>
<p>The feature-extraction functionality of <em>tsflex</em> is provided by a <code><a title="tsflex.features.FeatureCollection" href="#tsflex.features.FeatureCollection">FeatureCollection</a></code> that contains <code><a title="tsflex.features.FeatureDescriptor" href="#tsflex.features.FeatureDescriptor">FeatureDescriptor</a></code>s. The features are calculated (in a parallel manner) on the data that is passed to the feature collection.</p>
<h3 id="components">Components</h3>
<p><img alt="features uml" src="https://raw.githubusercontent.com/predict-idlab/tsflex/main/docs/_static/features_uml.png"></p>
<p>As shown above, there are 3 relevant classes for feature-extraction.</p>
<ol>
<li><a href="/tsflex/features/#tsflex.features.FeatureCollection">FeatureCollection</a>: serves as a registry, withholding the to-be-calculated <em>features</em></li>
<li><a href="/tsflex/features/#tsflex.features.FeatureDescriptor">FeatureDescriptor</a>: an instance of this class describes a <em>feature</em>. <br>Features are defined by:<ul>
<li><code>series_name</code>: the names of the input series on which the feature-function will operate </li>
<li><code>function</code>: the <em>Callable</em> feature-function - e.g. <em>np.mean</em></li>
<li><code>window</code>: the <em>time-based</em> window -
e.g. <em>"1hour"</em></li>
<li><code>stride</code>: the <em>time-based</em> stride - e.g. <em>"2days"</em></li>
</ul>
</li>
<li><a href="/tsflex/features/#tsflex.features.NumpyFuncWrapper">NumpyFuncWrapper</a>: a wrapper around <em>Callable</em> functions, intended for advanced feature-function definitions, such as:<ul>
<li>features with multiple output columns</li>
<li>passing <em>**kwargs</em> to feature functions</li>
</ul>
</li>
</ol>
<p>The snippet below shows how the <code><a title="tsflex.features.FeatureCollection" href="#tsflex.features.FeatureCollection">FeatureCollection</a></code> &amp; <code><a title="tsflex.features.FeatureDescriptor" href="#tsflex.features.FeatureDescriptor">FeatureDescriptor</a></code> components work together:</p>
<pre><code class="language-python">import numpy as np; import scipy.stats as ss
from tsflex.features import FeatureDescriptor, FeatureCollection

# The FeatureCollection takes a List[FeatureDescriptor] as input
fc = FeatureCollection(feature_descriptors=[
        # There is no need for NumpyFuncWrapper when using &quot;simple&quot; features
        FeatureDescriptor(np.mean, &quot;series_a&quot;, &quot;1hour&quot;, &quot;15min&quot;),
        FeatureDescriptor(ss.skew, &quot;series_b&quot;, &quot;3hours&quot;, &quot;5min&quot;)
    ]
)

# We can still add features after instantiating.
fc.add(features=[FeatureDescriptor(np.std, &quot;series_a&quot;, &quot;1hour&quot;, &quot;15min&quot;)])

# Calculate the features
fc.calculate(...)
</code></pre>
<h3 id="feature-functions">Feature functions</h3>
<p>The function that processes the series should match this prototype:</p>
<pre><code>function(*series: np.ndarray, **kwargs)
    -&gt; Union[Any, List[Any]]
</code></pre>
<!-- TODO: waarom geen pd.Series?? -->
<p>Hence, the feature function should take one (or multiple) arrays as input, these may be followed by some keyword arguments. The output of a feature function can be rather versatile (e.g., a float, an integer, a string, a bool, &hellip; or a list thereof).</p>
<p>In <a href="#advanced-usage">this section</a> you can find more info on advanced usage of feature functions.</p>
<h3 id="multiple-feature-descriptors">Multiple feature descriptors</h3>
<p>Sometimes it can get overly verbose when the same feature is shared over multiple series, windows and/or strides. To solve this proble, we introduce the <code><a title="tsflex.features.MultipleFeatureDescriptors" href="#tsflex.features.MultipleFeatureDescriptors">MultipleFeatureDescriptors</a></code>, this component allows to <strong>create multiple feature descriptors for all</strong> the <code>function - series_name(s) - window - stride</code> <strong>combinations</strong>.</p>
<p>A <code><a title="tsflex.features.MultipleFeatureDescriptors" href="#tsflex.features.MultipleFeatureDescriptors">MultipleFeatureDescriptors</a></code> instance can be added a <code><a title="tsflex.features.FeatureCollection" href="#tsflex.features.FeatureCollection">FeatureCollection</a></code>.</p>
<p>Example</p>
<pre><code class="language-python">import numpy as np; import scipy.stats as ss
from tsflex.features import FeatureDescriptor, FeatureCollection
from tsflex.features import MultipleFeatureDescriptors

# The FeatureCollection takes a List[FeatureDescriptor] as input
fc = FeatureCollection(feature_descriptors=[
        # There is no need for NumpyFuncWrapper when using &quot;simple&quot; features
        FeatureDescriptor(np.mean, &quot;series_a&quot;, &quot;1hour&quot;, &quot;15min&quot;),
        FeatureDescriptor(ss.skew, &quot;series_b&quot;, &quot;3hours&quot;, &quot;5min&quot;),
        MultipleFeatureDescriptors(
            functions=[np.min, np.max, np.std, ss.skew],
            series_names=[&quot;series_a&quot;, &quot;series_b&quot;, &quot;series_c&quot;],
            windows=[&quot;5min&quot;, &quot;15min&quot;],
            strides=[&quot;1min&quot;,&quot;2min&quot;,&quot;3min&quot;]
        )
    ]
)

# Calculate the features
fc.calculate(...)
</code></pre>
<h3 id="output-format">Output format</h3>
<p>The output of the <code><a title="tsflex.features.FeatureCollection" href="#tsflex.features.FeatureCollection">FeatureCollection</a></code> its <code>calculate</code> method is a (list of) <strong><code>time-indexed pd.DataFrame</code></strong> with column names<br></p>
<blockquote>
<p><strong><code>&lt;SERIES-NAME&gt;__&lt;FEAT-NAME&gt;__w=&lt;WINDOW&gt;__s=&lt;STRIDE&gt;</code></strong>.</p>
</blockquote>
<p>The column-name for the feature defined on the penultimate line in the snipped above will thus be <code>series_a__std__w=1h__s=15m</code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>You can find more information about the <strong>input data-formats</strong> in <a href="/tsflex/#data-formats">this section</a> and read more about the (obvious) <strong>limitations</strong> in the next section.</p>
</div>
<p><br></p>
<h2 id="limitations">Limitations ‚ö†Ô∏è</h2>
<p>It is important to note that there a still some, albeit logical, <strong>limitations</strong> regarding the supported <a href="/tsflex/#data-formats">data format</a>.</p>
<p>These limitations are:</p>
<ol>
<li>Each <a href="/tsflex/#data-formats"><code>ts</code></a> must have a <b style="color:red"><code>pd.DatetimeIndex</code> that increases monotonically</b><ul>
<li><strong>Countermeasure</strong>: Apply <em><a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.sort_index.html">sort_index()</a></em> on your not-monotonically increasing data</li>
</ul>
</li>
<li><b style="color:red">No duplicate</b> <code>ts</code> <b style="color:red">names</b> are allowed<ul>
<li><strong>Countermeasure</strong>: rename your <code>ts</code></li>
</ul>
</li>
</ol>
<p><br></p>
<h2 id="important-notes">Important notes üì¢</h2>
<ul>
<li>We support various data-types. e.g. (np.float32, string-data, time-based data). However, it is the end-users responsibility to use a function which interplays nicely with the data its format.</li>
</ul>
<p><br></p>
<h2 id="advanced-usage">Advanced usage üëÄ</h2>
<h3 id="versatile-functions">Versatile functions</h3>
<p><code>TODO</code> </p>
<!-- hier NumpyFuncWrapper shillen -->
<!-- TODO: tot hier geraakt -->
<h3 id="multivariate-data">Multivariate-data</h3>
<p>There are no assumptions made about the <code>data</code> its <code>time-ranges</code>.<br>
However, the end-user must take some things in consideration.</p>
<h3 id="multiple-time-series">Multiple time series</h3>
<ul>
<li>functions that work on <strong>multiple time series</strong>: see the <code><a title="tsflex.chunking" href="../chunking/index.html">tsflex.chunking</a></code> module for more info.</li>
</ul>
<h3 id="irregularly-sampled-data">Irregularly sampled data</h3>
<p>This case may cause that not all windows on which features are calculated have the same amount of samples.<br>
When using multivariate data, with either different sample rates or with an irregular data-rate, you cannot make the assumption that all windows will have the same length. Your feature extraction method will thus
* will the s </p>
<h3 id="logging">Logging</h3>
<p>When a <code>logging_file_path</code> is passed to the <code><a title="tsflex.features.FeatureCollection" href="#tsflex.features.FeatureCollection">FeatureCollection</a></code> its <code>calculate</code> method, the execution times of the feature functions will be logged.</p>
<p><a href="#tsflex.features.get_feature_logs">More info</a></p>
<p><br></p>
<hr>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Feature extraction submodule.

.. include:: ../../docs/pdoc_include/features.md

&#34;&#34;&#34;

__author__ = &#34;Jonas Van Der Donckt, Jeroen Van Der Donckt, Emiel Deprost&#34;

from .. import __pdoc__
from .feature import FeatureDescriptor, MultipleFeatureDescriptors
from .feature_collection import FeatureCollection
from .function_wrapper import NumpyFuncWrapper
from .logger import get_feature_logs, get_function_stats, get_series_names_stats

__pdoc__[&#34;NumpyFuncWrapper.__call__&#34;] = True

__all__ = [
    &#34;FeatureDescriptor&#34;,
    &#34;MultipleFeatureDescriptors&#34;,
    &#34;FeatureCollection&#34;,
    &#34;NumpyFuncWrapper&#34;,
    &#34;get_feature_logs&#34;,
    &#34;get_function_stats&#34;,
    &#34;get_series_names_stats&#34;,
]</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="tsflex.features.feature" href="feature.html">tsflex.features.feature</a></code></dt>
<dd>
<div class="desc"><p>FeatureDescriptor and MultipleFeatureDescriptors class for creating time-series
features.</p></div>
</dd>
<dt><code class="name"><a title="tsflex.features.feature_collection" href="feature_collection.html">tsflex.features.feature_collection</a></code></dt>
<dd>
<div class="desc"><p>FeatureCollection class for bookkeeping and calculation of time-series features ‚Ä¶</p></div>
</dd>
<dt><code class="name"><a title="tsflex.features.function_wrapper" href="function_wrapper.html">tsflex.features.function_wrapper</a></code></dt>
<dd>
<div class="desc"><p>NumpyFuncWrapper class for object-oriented representation of a function.</p></div>
</dd>
<dt><code class="name"><a title="tsflex.features.logger" href="logger.html">tsflex.features.logger</a></code></dt>
<dd>
<div class="desc"><p>Contains the used variables and functions to provide logging functionality ‚Ä¶</p></div>
</dd>
<dt><code class="name"><a title="tsflex.features.strided_rolling" href="strided_rolling.html">tsflex.features.strided_rolling</a></code></dt>
<dd>
<div class="desc"><p>Contains a (rather) fast implementation of a <strong>time-based</strong> strided rolling window ‚Ä¶</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="tsflex.features.get_feature_logs"><code class="name flex">
<span>def <span class="ident">get_feature_logs</span></span>(<span>logging_file_path)</span>
</code></dt>
<dd>
<div class="desc"><p>Get execution (time) info for each feature of a <code><a title="tsflex.features.FeatureCollection" href="#tsflex.features.FeatureCollection">FeatureCollection</a></code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>logging_file_path</code></strong> :&ensp;<code>str</code></dt>
<dd>The file path where the logged messages are stored. This is the file path that
is passed to the <code><a title="tsflex.features.FeatureCollection" href="#tsflex.features.FeatureCollection">FeatureCollection</a></code> its <code>calculate</code> method.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pd.DataFrame</code></dt>
<dd>A DataFrame with the features its function, input series names and
calculation duration.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_feature_logs(logging_file_path: str) -&gt; pd.DataFrame:
    &#34;&#34;&#34;Get execution (time) info for each feature of a `FeatureCollection`.

    Parameters
    ----------
    logging_file_path: str
        The file path where the logged messages are stored. This is the file path that
        is passed to the `FeatureCollection` its `calculate` method.

    Returns
    -------
    pd.DataFrame
        A DataFrame with the features its function, input series names and 
        calculation duration.

    &#34;&#34;&#34;
    df = _parse_logging_execution_to_df(logging_file_path)
    df[&#34;duration&#34;] = pd.to_timedelta(df[&#34;duration&#34;], unit=&#34;s&#34;)
    return df</code></pre>
</details>
</dd>
<dt id="tsflex.features.get_function_stats"><code class="name flex">
<span>def <span class="ident">get_function_stats</span></span>(<span>logging_file_path)</span>
</code></dt>
<dd>
<div class="desc"><p>Get execution (time) statistics for each function.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>logging_file_path</code></strong> :&ensp;<code>str</code></dt>
<dd>The file path where the logged messages are stored. This is the file path that
is passed to the <code><a title="tsflex.features.FeatureCollection" href="#tsflex.features.FeatureCollection">FeatureCollection</a></code> its <code>calculate</code> method.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pd.DataFrame</code></dt>
<dd>A DataFrame with for each function (i.e., <code>function-(window,stride)</code>)
combination the mean (time), std (time), sum (time), and number of executions.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_function_stats(logging_file_path: str) -&gt; pd.DataFrame:
    &#34;&#34;&#34;Get execution (time) statistics for each function.

    Parameters
    ----------
    logging_file_path: str
        The file path where the logged messages are stored. This is the file path that
        is passed to the `FeatureCollection` its `calculate` method.

    Returns
    -------
    pd.DataFrame
        A DataFrame with for each function (i.e., `function-(window,stride)`) 
        combination the mean (time), std (time), sum (time), and number of executions.

    &#34;&#34;&#34;
    df = _parse_logging_execution_to_df(logging_file_path)
    return (
        df.groupby([&#34;function&#34;, &#34;window&#34;, &#34;stride&#34;])
        .agg({&#34;duration&#34;: [&#34;mean&#34;, &#34;std&#34;, &#34;sum&#34;, &#34;count&#34;]})
        .sort_values(by=(&#34;duration&#34;, &#34;mean&#34;), ascending=False)
    )</code></pre>
</details>
</dd>
<dt id="tsflex.features.get_series_names_stats"><code class="name flex">
<span>def <span class="ident">get_series_names_stats</span></span>(<span>logging_file_path)</span>
</code></dt>
<dd>
<div class="desc"><p>Get execution (time) statistics for each <code>key-(window,stride)</code> combination.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>logging_file_path</code></strong> :&ensp;<code>str</code></dt>
<dd>The file path where the logged messages are stored. This is the file path that
is passed to the <code><a title="tsflex.features.FeatureCollection" href="#tsflex.features.FeatureCollection">FeatureCollection</a></code> its <code>calculate</code> method.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pd.DataFrame</code></dt>
<dd>A DataFrame with for each function the mean (time), std (time), sum (time), and
number of executions.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_series_names_stats(logging_file_path: str) -&gt; pd.DataFrame:
    &#34;&#34;&#34;Get execution (time) statistics for each `key-(window,stride)` combination.

    Parameters
    ----------
    logging_file_path: str
        The file path where the logged messages are stored. This is the file path that
        is passed to the `FeatureCollection` its `calculate` method.

    Returns
    -------
    pd.DataFrame
        A DataFrame with for each function the mean (time), std (time), sum (time), and
        number of executions.

    &#34;&#34;&#34;
    df = _parse_logging_execution_to_df(logging_file_path)
    return (
        df.groupby([&#34;series_names&#34;, &#34;window&#34;, &#34;stride&#34;])
        .agg({&#34;duration&#34;: [&#34;sum&#34;, &#34;mean&#34;, &#34;std&#34;, &#34;count&#34;]})
        .sort_values(by=(&#34;duration&#34;, &#34;sum&#34;), ascending=False)
    )</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="tsflex.features.FeatureDescriptor"><code class="flex name class">
<span>class <span class="ident">FeatureDescriptor</span></span>
<span>(</span><span>function, series_name, window, stride)</span>
</code></dt>
<dd>
<div class="desc"><p>A FeatureDescriptor object, containing all feature information.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>function</code></strong> :&ensp;<code>Union[<a title="tsflex.features.NumpyFuncWrapper" href="#tsflex.features.NumpyFuncWrapper">NumpyFuncWrapper</a>, Callable]</code></dt>
<dd>The function that calculates this feature.
The prototype of the function should match: <pre><code>function(*series: np.ndarray)
    -&gt; Union[Any, List[Any]]
</code></pre>
</dd>
<dt><strong><code>series_name</code></strong> :&ensp;<code>Union[str, Tuple[str, &hellip;]]</code></dt>
<dd>
<p>The names of the series on which the feature function should be applied.
This argument should match the <code>function</code> its input; </p>
<ul>
<li>If <code>series_name</code> is a string (or tuple of a single string), than
<code>function</code> should require just one series as input.</li>
<li>If <code>series_name</code> is a tuple of strings, than <code>function</code> should
require <code>len(tuple)</code> series as input <strong>and in exactly the same order</strong></li>
</ul>
</dd>
<dt><strong><code>window</code></strong> :&ensp;<code>Union[float, str, pd.Timedelta]</code></dt>
<dd>
<p>The window size, this argument supports multiple types: </p>
<ul>
<li>If the type is an <code>float</code>, it represents the series its window size in
<strong>seconds</strong>.</li>
<li>If the window's type is a <code>pd.Timedelta</code>, the window size represents
the window-time.</li>
<li>
<p>If a <code>str</code>, it represents a window-time-string. </p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When no time-unit is present in the string, it represents the stride
size in <strong>seconds</strong>.</p>
</div>
</li>
</ul>
</dd>
<dt><strong><code>stride</code></strong> :&ensp;<code>Union[int, str, pd.Timedelta]</code></dt>
<dd>
<p>The stride of the window rolling process, supports multiple types: </p>
<ul>
<li>If the type is <code>float</code>, it represents the stride size in <strong>seconds</strong></li>
<li>If the type is <code>pd.Timedelta</code>, it represents the stride-roll timedelta.</li>
<li>
<p>If a type is <code>str</code>, it represents a stride-roll-time-string. </p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When no time-unit is present in the string, it represents the stride
size in <strong>seconds</strong>.</p>
</div>
</li>
</ul>
</dd>
</dl>
<h2 id="notes">Notes</h2>
<ul>
<li>For each <code>function</code> - <code>input</code>(-series) - <code>window</code> - stride combination, one needs
to create a distinct <code><a title="tsflex.features.FeatureDescriptor" href="#tsflex.features.FeatureDescriptor">FeatureDescriptor</a></code>. Hence it is more convenient to
create a <code><a title="tsflex.features.MultipleFeatureDescriptors" href="#tsflex.features.MultipleFeatureDescriptors">MultipleFeatureDescriptors</a></code> when <code>function</code> - <code>window</code> - <code>stride</code>
<em>combinations</em> should be applied on various input-series (combinations).</li>
<li>When <code>function</code> takes multiple series (i.e., arguments) as input, these are
joined (based on the index) before applying the function. If the indexes of
these series are not exactly the same, it might occur that not all series have
exactly the same length! Hence,
make sure that the <code>function</code> can deal with
this!</li>
<li>For more information about the str-based time args, look into:
<a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/timedeltas.html#parsing" target="_blank">pandas time delta</a>
<br><br></li>
</ul>
<div class="admonition todo">
<p class="admonition-title">TODO</p>
<ul>
<li>Add documentation of how the index/slicing takes place / which
assumptions we make.</li>
<li>Raise error function tries to change values of view due to flag</li>
</ul>
</div>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>Raised when the <code>function</code> is not an instance of Callable or
NumpyFuncWrapper.</dd>
</dl>
<h2 id="see-also">See Also</h2>
<dl>
<dt><code>StridedRolling</code></dt>
<dd>As the window-stride (time) conversion takes place there.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FeatureDescriptor(FrozenClass):
    &#34;&#34;&#34;A FeatureDescriptor object, containing all feature information.

    Parameters
    ----------
    function : Union[NumpyFuncWrapper, Callable]
        The function that calculates this feature.
        The prototype of the function should match: \n

            function(*series: np.ndarray)
                -&gt; Union[Any, List[Any]]

    series_name : Union[str, Tuple[str, ...]]
        The names of the series on which the feature function should be applied.
        This argument should match the `function` its input; \n
        * If `series_name` is a string (or tuple of a single string), than 
            `function` should require just one series as input.
        * If `series_name` is a tuple of strings, than `function` should
            require `len(tuple)` series as input **and in exactly the same order**
    window : Union[float, str, pd.Timedelta]
        The window size, this argument supports multiple types: \n
        * If the type is an `float`, it represents the series its window size in
            **seconds**.
        * If the window&#39;s type is a `pd.Timedelta`, the window size represents
            the window-time.
        * If a `str`, it represents a window-time-string. \n
            .. Note::
                When no time-unit is present in the string, it represents the stride
                size in **seconds**.

    stride : Union[int, str, pd.Timedelta]
        The stride of the window rolling process, supports multiple types: \n
        * If the type is `float`, it represents the stride size in **seconds**
        * If the type is `pd.Timedelta`, it represents the stride-roll timedelta.
        * If a type is `str`, it represents a stride-roll-time-string. \n
            .. Note::
                When no time-unit is present in the string, it represents the stride
                size in **seconds**.

    Notes
    -----
    * For each `function` - `input`(-series) - `window` - stride combination, one needs
      to create a distinct `FeatureDescriptor`. Hence it is more convenient to
      create a `MultipleFeatureDescriptors` when `function` - `window` - `stride`
      _combinations_ should be applied on various input-series (combinations).
    * When `function` takes multiple series (i.e., arguments) as input, these are
      joined (based on the index) before applying the function. If the indexes of
      these series are not exactly the same, it might occur that not all series have
      exactly the same length! Hence,  make sure that the `function` can deal with
      this!
    * For more information about the str-based time args, look into:
      [pandas time delta](https://pandas.pydata.org/pandas-docs/stable/user_guide/timedeltas.html#parsing){:target=&#34;_blank&#34;}
    &lt;br&gt;&lt;br&gt;
    .. todo::
        * Add documentation of how the index/slicing takes place / which
          assumptions we make.
        * Raise error function tries to change values of view due to flag


    Raises
    ------
    TypeError
        Raised when the `function` is not an instance of Callable or
        NumpyFuncWrapper.

    See Also
    --------
    StridedRolling: As the window-stride (time) conversion takes place there.

    &#34;&#34;&#34;

    def __init__(
        self,
        function: Union[NumpyFuncWrapper, Callable],
        series_name: Union[str, Tuple[str, ...]],
        window: Union[float, str, pd.Timedelta],
        stride: Union[float, str, pd.Timedelta],
    ):
        self.series_name: Tuple[str, ...] = to_tuple(series_name)
        self.window: pd.Timedelta = parse_time_arg(window)
        self.stride: pd.Timedelta = parse_time_arg(stride)

        # Order of if statements is important (as NumpyFuncWrapper also is a Callable)!
        if isinstance(function, NumpyFuncWrapper):
            self.function: NumpyFuncWrapper = function
        elif isinstance(function, Callable):
            self.function: NumpyFuncWrapper = NumpyFuncWrapper(function)
        else:
            raise TypeError(
                &#34;Expected feature function to be a `NumpyFuncWrapper` but is a&#34;
                f&#34; {type(function)}.&#34;
            )

        # Construct a function-string
        f_name = str(self.function)
        self._func_str: str = f&#34;{self.__class__.__name__} - func: {f_name}&#34;

        self._freeze()

    def get_required_series(self) -&gt; List[str]:
        &#34;&#34;&#34;Return all required series names for this feature descriptor.

        Return the list of series names that are required in order to execute the
        feature function.

        Returns
        -------
        List[str]
            List of all the required series names.

        &#34;&#34;&#34;
        return list(set(self.series_name))        

    def __repr__(self) -&gt; str:
        &#34;&#34;&#34;Representation string of Feature.&#34;&#34;&#34;
        return f&#34;{self.__class__.__name__}({self.series_name}, {self.window}, &#34; \
               f&#34;{self.stride})&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>tsflex.utils.classes.FrozenClass</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="tsflex.features.FeatureDescriptor.get_required_series"><code class="name flex">
<span>def <span class="ident">get_required_series</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return all required series names for this feature descriptor.</p>
<p>Return the list of series names that are required in order to execute the
feature function.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List[str]</code></dt>
<dd>List of all the required series names.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_required_series(self) -&gt; List[str]:
    &#34;&#34;&#34;Return all required series names for this feature descriptor.

    Return the list of series names that are required in order to execute the
    feature function.

    Returns
    -------
    List[str]
        List of all the required series names.

    &#34;&#34;&#34;
    return list(set(self.series_name))        </code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="tsflex.features.MultipleFeatureDescriptors"><code class="flex name class">
<span>class <span class="ident">MultipleFeatureDescriptors</span></span>
<span>(</span><span>functions, series_names, windows, strides)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a MultipleFeatureDescriptors object.</p>
<p>Create a list of features from <strong>all</strong> combinations of the given parameter
lists. Total number of created Features will be:</p>
<pre><code>len(func_inputs)*len(functions)*len(windows)*len(strides).
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>functions</code></strong> :&ensp;<code>Union[<a title="tsflex.features.NumpyFuncWrapper" href="#tsflex.features.NumpyFuncWrapper">NumpyFuncWrapper</a>, Callable, List[Union[<a title="tsflex.features.NumpyFuncWrapper" href="#tsflex.features.NumpyFuncWrapper">NumpyFuncWrapper</a>, Callable]]]</code></dt>
<dd>The functions, can be either of both types (even in a single array).</dd>
<dt><strong><code>series_names</code></strong> :&ensp;<code>Union[str, Tuple[str, &hellip;], List[str], List[Tuple[str, &hellip;]]]</code></dt>
<dd>
<p>The names of the series on which the feature function should be applied.</p>
<p>This argument should match the <code>function</code> its input; </p>
<ul>
<li>If <code>series_names</code> is a (list of) string (or tuple of a single string),
than <code>function</code> should require just one series as input.</li>
<li>If <code>series_names</code> is a (list of) tuple of strings, than <code>function</code> should
require <code>len(tuple)</code> series as input.</li>
</ul>
<p>A list means multiple series (combinations) to extract feature from; </p>
<ul>
<li>If <code>series_names</code> is a string or a tuple of strings, than <code>function</code> will
be called only once for the series of this argument.</li>
<li>If <code>series_names</code> is a list of either strings or tuple of strings, than
<code>function</code> will be called for each entry of this list.</li>
</ul>
<p>Note: when passing a list as <code>series_names</code>, all items in this list should
have the same type, i.e, either </p>
<ul>
<li>all a str</li>
<li>or, all a tuple <em>with same length</em>.</li>
</ul>
</dd>
<dt><strong><code>windows</code></strong> :&ensp;<code>Union[float, str, pd.Timedelta, List[Union[float, str, pd.Timedelta]]],</code></dt>
<dd>All the window sizes.</dd>
<dt><strong><code>strides</code></strong> :&ensp;<code>Union[float, str, pd.Timedelta, List[Union[float, str, pd.Timedelta]]],</code></dt>
<dd>All the strides.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MultipleFeatureDescriptors:
    &#34;&#34;&#34;Create a MultipleFeatureDescriptors object.

    Create a list of features from **all** combinations of the given parameter
    lists. Total number of created Features will be:

        len(func_inputs)*len(functions)*len(windows)*len(strides).

    Parameters
    ----------
    functions : Union[NumpyFuncWrapper, Callable, List[Union[NumpyFuncWrapper, Callable]]]
        The functions, can be either of both types (even in a single array).
    series_names : Union[str, Tuple[str, ...], List[str], List[Tuple[str, ...]]]
        The names of the series on which the feature function should be applied.

        This argument should match the `function` its input; \n
        * If `series_names` is a (list of) string (or tuple of a single string),
          than `function` should require just one series as input.
        * If `series_names` is a (list of) tuple of strings, than `function` should
          require `len(tuple)` series as input.

        A list means multiple series (combinations) to extract feature from; \n
        * If `series_names` is a string or a tuple of strings, than `function` will
          be called only once for the series of this argument.
        * If `series_names` is a list of either strings or tuple of strings, than
          `function` will be called for each entry of this list.

        Note: when passing a list as `series_names`, all items in this list should
        have the same type, i.e, either \n
        * all a str
        * or, all a tuple _with same length_. \n
    windows : Union[float, str, pd.Timedelta, List[Union[float, str, pd.Timedelta]]],
        All the window sizes.
    strides : Union[float, str, pd.Timedelta, List[Union[float, str, pd.Timedelta]]],
        All the strides.

    &#34;&#34;&#34;
    def __init__(
        self,
        functions: Union[NumpyFuncWrapper, Callable, List[Union[NumpyFuncWrapper, Callable]]],
        series_names: Union[str, Tuple[str, ...], List[str], List[Tuple[str, ...]]],
        windows: Union[float, str, pd.Timedelta, List[Union[float, str, pd.Timedelta]]],
        strides: Union[float, str, pd.Timedelta, List[Union[float, str, pd.Timedelta]]],
    ):
        # Cast functions to NumpyFuncWrapper, this avoids creating multiple
        # NumpyFuncWrapper objects for the same function in the FeatureDescriptor
        def to_np_func_wrapper(f: Callable): 
            return f if isinstance(f, NumpyFuncWrapper) else NumpyFuncWrapper(f)
        functions = [to_np_func_wrapper(f) for f in to_list(functions)]
        # Convert the series names to list of tuples
        series_names = [to_tuple(names) for names in to_list(series_names)]
        # Assert that function inputs (series) all have the same length
        assert all(
            len(series_names[0]) == len(series_name_tuple)
            for series_name_tuple in series_names
        )
        # Convert the other types to list
        windows = to_list(windows)
        strides = to_list(strides)

        self.feature_descriptions: List[FeatureDescriptor] = []
        # Iterate over all combinations
        combinations = [functions, series_names, windows, strides]
        for function, series_name, window, stride in itertools.product(*combinations):
            self.feature_descriptions.append(
                FeatureDescriptor(function, series_name, window, stride)
            )</code></pre>
</details>
</dd>
<dt id="tsflex.features.FeatureCollection"><code class="flex name class">
<span>class <span class="ident">FeatureCollection</span></span>
<span>(</span><span>feature_descriptors=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a FeatureCollection.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>feature_descriptors</code></strong> :&ensp;<code>Union[<a title="tsflex.features.FeatureDescriptor" href="#tsflex.features.FeatureDescriptor">FeatureDescriptor</a>, <a title="tsflex.features.MultipleFeatureDescriptors" href="#tsflex.features.MultipleFeatureDescriptors">MultipleFeatureDescriptors</a>, List[Union[<a title="tsflex.features.FeatureDescriptor" href="#tsflex.features.FeatureDescriptor">FeatureDescriptor</a>, <a title="tsflex.features.MultipleFeatureDescriptors" href="#tsflex.features.MultipleFeatureDescriptors">MultipleFeatureDescriptors</a>]]]</code>, optional</dt>
<dd>Initial (list of) feature(s) to add to collection, by default None</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FeatureCollection:
    &#34;&#34;&#34;Create a FeatureCollection.

    Parameters
    ----------
    feature_descriptors : Union[FeatureDescriptor, MultipleFeatureDescriptors, List[Union[FeatureDescriptor, MultipleFeatureDescriptors]]], optional
        Initial (list of) feature(s) to add to collection, by default None

    &#34;&#34;&#34;

    def __init__(
        self,
        feature_descriptors: Optional[
            Union[
                FeatureDescriptor,
                MultipleFeatureDescriptors,
                List[Union[FeatureDescriptor, MultipleFeatureDescriptors]],
            ]
        ] = None,
    ):
        # The feature collection is a dict with keys of type:
        #   tuple(tuple(str), float OR pd.timedelta, float OR pd.timedelta)
        # The outer tuple&#39;s values correspond to (series_key(s), window, stride)
        self._feature_desc_dict: Dict[
            Tuple[Tuple[str, ...], pd.Timedelta, pd.Timedelta], List[FeatureDescriptor]
        ] = {}

        if feature_descriptors:
            self.add(feature_descriptors)

    def get_required_series(self) -&gt; List[str]:
        &#34;&#34;&#34;Return all required series names for this feature collection.

        Return the list of series names that are required in order to calculate all the
        features (defined by the `FeatureDescriptor` objects) of this feature
        collection.

        Returns
        -------
        List[str]
            List of all the required series names.

        &#34;&#34;&#34;
        return list(
            set(flatten([fr_key[0] for fr_key in self._feature_desc_dict.keys()]))
        )

    @staticmethod
    def _get_collection_key(
        feature: FeatureDescriptor,
    ) -&gt; Tuple[tuple, pd.Timedelta, pd.Timedelta]:
        # Note: `window` &amp; `stride` properties can either be a pd.Timedelta or an int
        return feature.series_name, feature.window, feature.stride

    def _add_feature(self, feature: FeatureDescriptor):
        &#34;&#34;&#34;Add a `FeatureDescriptor` instance to the collection.

        Parameters
        ----------
        feature : FeatureDescriptor
            The feature that will be added to this feature collection.

        &#34;&#34;&#34;
        series_win_stride_key = self._get_collection_key(feature)
        if series_win_stride_key in self._feature_desc_dict.keys():
            self._feature_desc_dict[series_win_stride_key].append(feature)
        else:
            self._feature_desc_dict[series_win_stride_key] = [feature]

    def add(
        self,
        features: Union[
            FeatureDescriptor, 
            MultipleFeatureDescriptors,
            FeatureCollection,
            List[
                Union[FeatureDescriptor, MultipleFeatureDescriptors, FeatureCollection]
            ],
        ],
    ):
        &#34;&#34;&#34;Add feature(s) to the FeatureCollection.

        Parameters
        ----------
        features : Union[FeatureDescriptor, MultipleFeatureDescriptors, FeatureCollection, List[Union[FeatureDescriptor, MultipleFeatureDescriptors, FeatureCollection]]]
            Feature(s) (containers) whose contained features will be added.

        Raises
        ------
        TypeError
            Raised when an item within `features` is not an instance of
            [`MultipleFeatureDescriptors`, `FeatureDescriptors`, `FeatureCollection`].

        &#34;&#34;&#34;
        # Convert to list if necessary
        features = to_list(features)

        for feature in features:
            if isinstance(feature, MultipleFeatureDescriptors):
                self.add(feature.feature_descriptions)
            elif isinstance(feature, FeatureDescriptor):
                self._add_feature(feature)
            elif isinstance(feature, FeatureCollection):
                # List needs to be flattened
                self.add(list(flatten(feature._feature_desc_dict.values())))
            else:
                raise TypeError(f&#34;type: {type(feature)} is not supported - {feature}&#34;)

    @staticmethod
    def _executor(idx: int):
        # global get_stroll_func
        stroll, function = get_stroll_func(idx)
        return stroll.apply_func(function)

    def _stroll_feat_generator(
        self, series_dict: Dict[str, pd.Series], window_idx: str, approve_sparsity: bool
    ) -&gt; List[Tuple[StridedRolling, NumpyFuncWrapper]]:
        # --- Future work ---
        # We could also make the StridedRolling creation multithreaded
        # Very low priority because the STROLL __init__ is rather efficient!
        keys_wins_strides = list(self._feature_desc_dict.keys())
        lengths = np.cumsum(
            [len(self._feature_desc_dict[k]) for k in keys_wins_strides]
        )

        def get_stroll_function(idx):
            key_idx = np.searchsorted(lengths, idx, &#34;right&#34;)  # right bc idx starts at 0
            key, win, stride = keys_wins_strides[key_idx]
            stroll = StridedRolling(
                data=[series_dict[k] for k in key],
                window=win,
                stride=stride,
                window_idx=window_idx,
                approve_sparsity=approve_sparsity,
            )
            feature = self._feature_desc_dict[keys_wins_strides[key_idx]][
                idx - lengths[key_idx]
            ]
            return stroll, feature.function

        return get_stroll_function

    def _get_stroll_feat_length(self) -&gt; int:
        return sum(
            len(self._feature_desc_dict[k]) for k in self._feature_desc_dict.keys()
        )

    def calculate(
        self,
        data: Union[pd.Series, pd.DataFrame, List[Union[pd.Series, pd.DataFrame]]],
        return_df: Optional[bool] = False,
        window_idx: Optional[str] = &#34;end&#34;,
        approve_sparsity: Optional[bool] = False,
        show_progress: Optional[bool] = False,
        logging_file_path: Optional[Union[str, Path]] = None,
        n_jobs: Optional[int] = None,
    ) -&gt; Union[List[pd.DataFrame], pd.DataFrame]:
        &#34;&#34;&#34;Calculate features on the passed data.

        Notes
        ------
        * The (column-)names of the series in `data` represent the names in the keys.
        * If a `logging_file_path` is provided, the execution (time) info can be
          retrieved by calling `logger.get_feature_logs(logging_file_path)`.
          Be aware that the `logging_file_path` gets cleared before the logger pushes
          logged messages. Hence, one should use a separate logging file for each
          constructed processing and feature instance with this library.

        Parameters
        ----------
        data : Union[pd.Series, pd.DataFrame, List[Union[pd.Series, pd.DataFrame]]]
            Dataframe or Series or list thereof, with all the required data for the
            feature calculation. \n
            **Remark**: each Series / DataFrame must have a `pd.DatetimeIndex`.
            **Remark**: we assume that each name / column is unique.
        return_df : bool, optional
            Whether the output needs to be a dataframe list or a DataFrame, by default
            False.
            If `True` the output dataframes will be merged to a DataFrame with an outer
            merge.
        window_idx : str, optional
            The window&#39;s index position which will be used as index for the
            feature_window aggregation. Must be either of: [&#39;begin&#39;, &#39;middle&#39;, &#39;end&#39;],
            by default &#39;end&#39;. All features in this collection will use the same
            window_idx.
        approve_sparsity: bool, optional
            Bool indicating whether the user acknowledges that there may be sparsity
            (i.e., irregularly sampled data), by default False.
            If False and sparsity is observed, a warning is raised.
        show_progress: bool, optional
            If True, the progress will be shown with a progressbar, by default False.
        logging_file_path : Union[str, Path], optional
            The file path where the logged messages are stored. If `None`, then no
            logging `FileHandler` will be used and the logging messages are only pushed
            to stdout. Otherwise, a logging `FileHandler` will write the logged messages
            to the given file path.
        n_jobs : int, optional
            The number of processes used for the feature calculation. If `None`, then
            the number returned by `os.cpu_count()` is used, by default None. \n
            If n_jobs is either 0 or 1, the code will be executed sequentially without
            creating a process pool. This is very useful when debugging, as the stack
            trace will be more comprehensible.

            .. tip::
                * It takes on avg. _300ms_ to schedule everything with
                  multiprocessing. So if your feature extraction code runs faster than
                  ~1.5s, it might not be worth it to parallelize the process
                  (and thus better set the `n_jobs` to 0-1).
                * This method its memory peaks are significantly lower when executed
                  sequentially. Set the `n_jobs` to 0-1 if this matters.

        Returns
        -------
        Union[List[pd.DataFrame], pd.DataFrame]
            The calculated features.

        Raises
        ------
        KeyError
            Raised when a required key is not found in `data`.

        &#34;&#34;&#34;
        # Delete other logging handlers
        delete_logging_handlers(logger)
        # Add logging handler (if path provided)
        if logging_file_path:
            add_logging_handler(logger, logging_file_path)

        # Convert the data to a series_dict
        series_dict: Dict[str, pd.Series] = {}
        for s in to_series_list(data):
            # Assert the assumptions we make!
            assert isinstance(s.index, pd.DatetimeIndex)
            assert s.index.is_monotonic_increasing

            if s.name in self.get_required_series():
                series_dict[str(s.name)] = s

        calculated_feature_list: List[pd.DataFrame] = []
        
        # Note: this variable has a global scope so this is shared in multiprocessing
        global get_stroll_func
        get_stroll_func = self._stroll_feat_generator(
            series_dict, window_idx, approve_sparsity
        )
        nb_stroll_funcs = self._get_stroll_feat_length()

        if n_jobs is None: 
            n_jobs = os.cpu_count()
        n_jobs = min(n_jobs, nb_stroll_funcs)

        if n_jobs in [0, 1]:
            idxs = range(nb_stroll_funcs)
            if show_progress:
                idxs = tqdm(idxs)
            calculated_feature_list = [self._executor(idx) for idx in idxs]
        else:
            # https://pathos.readthedocs.io/en/latest/pathos.html#usage
            with ProcessPool(nodes=n_jobs, source=True) as pool:
                results = pool.uimap(
                    self._executor,
                    range(nb_stroll_funcs),
                )
                if show_progress:
                    results = tqdm(results, total=self._get_stroll_feat_length())
                calculated_feature_list = [f for f in results]
                # Close &amp; join - see: https://github.com/uqfoundation/pathos/issues/131
                pool.close()
                pool.join()
                # Clear because: https://github.com/uqfoundation/pathos/issues/111
                pool.clear()

        if return_df:
            return pd.concat(calculated_feature_list, axis=1, join=&#34;outer&#34;, copy=False)
        else:
            return calculated_feature_list

    def serialize(self, file_path: Union[str, Path]):
        &#34;&#34;&#34;Serialize this `FeatureCollection` instance.

        Parameters
        ----------
        file_path : Union[str, Path]
            The path where the `FeatureCollection` will be serialized.

        Notes
        -----
        * As we use [Dill](https://github.com/uqfoundation/dill){:target=&#34;_blank&#34;} to
          serialize the files, we can **also serialize functions which are defined in
          the local scope, like lambdas.**

        &#34;&#34;&#34;
        with open(file_path, &#34;wb&#34;) as f:
            dill.dump(self, f, recurse=True)

    def __repr__(self) -&gt; str:
        &#34;&#34;&#34;Representation string of a FeatureCollection.&#34;&#34;&#34;
        feature_keys = sorted(set(k[0] for k in self._feature_desc_dict.keys()))
        output_str = &#34;&#34;
        for feature_key in feature_keys:
            output_str += f&#34;{&#39;|&#39;.join(feature_key)}: (&#34;
            keys = (x for x in self._feature_desc_dict.keys() if x[0] == feature_key)
            for _, win_size, stride in keys:
                output_str += f&#34;\n\twin: &#34;
                win_str = timedelta_to_str(win_size)
                stride_str = timedelta_to_str(stride)
                output_str += f&#34;{str(win_str):&lt;6}, stride: {str(stride_str)}: [&#34;
                for feat_desc in self._feature_desc_dict[feature_key, win_size, stride]:
                    output_str += f&#34;\n\t\t{feat_desc._func_str},&#34;
                output_str += &#34;\n\t]&#34;
            output_str += &#34;\n)\n&#34;
        return output_str</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="tsflex.features.FeatureCollection.get_required_series"><code class="name flex">
<span>def <span class="ident">get_required_series</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return all required series names for this feature collection.</p>
<p>Return the list of series names that are required in order to calculate all the
features (defined by the <code><a title="tsflex.features.FeatureDescriptor" href="#tsflex.features.FeatureDescriptor">FeatureDescriptor</a></code> objects) of this feature
collection.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List[str]</code></dt>
<dd>List of all the required series names.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_required_series(self) -&gt; List[str]:
    &#34;&#34;&#34;Return all required series names for this feature collection.

    Return the list of series names that are required in order to calculate all the
    features (defined by the `FeatureDescriptor` objects) of this feature
    collection.

    Returns
    -------
    List[str]
        List of all the required series names.

    &#34;&#34;&#34;
    return list(
        set(flatten([fr_key[0] for fr_key in self._feature_desc_dict.keys()]))
    )</code></pre>
</details>
</dd>
<dt id="tsflex.features.FeatureCollection.add"><code class="name flex">
<span>def <span class="ident">add</span></span>(<span>self, features)</span>
</code></dt>
<dd>
<div class="desc"><p>Add feature(s) to the FeatureCollection.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>features</code></strong> :&ensp;<code>Union[<a title="tsflex.features.FeatureDescriptor" href="#tsflex.features.FeatureDescriptor">FeatureDescriptor</a>, <a title="tsflex.features.MultipleFeatureDescriptors" href="#tsflex.features.MultipleFeatureDescriptors">MultipleFeatureDescriptors</a>, <a title="tsflex.features.FeatureCollection" href="#tsflex.features.FeatureCollection">FeatureCollection</a>, List[Union[<a title="tsflex.features.FeatureDescriptor" href="#tsflex.features.FeatureDescriptor">FeatureDescriptor</a>, <a title="tsflex.features.MultipleFeatureDescriptors" href="#tsflex.features.MultipleFeatureDescriptors">MultipleFeatureDescriptors</a>, <a title="tsflex.features.FeatureCollection" href="#tsflex.features.FeatureCollection">FeatureCollection</a>]]]</code></dt>
<dd>Feature(s) (containers) whose contained features will be added.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>Raised when an item within <code>features</code> is not an instance of
[<code>MultipleFeatureDescriptors</code>, <code>FeatureDescriptors</code>, <code><a title="tsflex.features.FeatureCollection" href="#tsflex.features.FeatureCollection">FeatureCollection</a></code>].</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add(
    self,
    features: Union[
        FeatureDescriptor, 
        MultipleFeatureDescriptors,
        FeatureCollection,
        List[
            Union[FeatureDescriptor, MultipleFeatureDescriptors, FeatureCollection]
        ],
    ],
):
    &#34;&#34;&#34;Add feature(s) to the FeatureCollection.

    Parameters
    ----------
    features : Union[FeatureDescriptor, MultipleFeatureDescriptors, FeatureCollection, List[Union[FeatureDescriptor, MultipleFeatureDescriptors, FeatureCollection]]]
        Feature(s) (containers) whose contained features will be added.

    Raises
    ------
    TypeError
        Raised when an item within `features` is not an instance of
        [`MultipleFeatureDescriptors`, `FeatureDescriptors`, `FeatureCollection`].

    &#34;&#34;&#34;
    # Convert to list if necessary
    features = to_list(features)

    for feature in features:
        if isinstance(feature, MultipleFeatureDescriptors):
            self.add(feature.feature_descriptions)
        elif isinstance(feature, FeatureDescriptor):
            self._add_feature(feature)
        elif isinstance(feature, FeatureCollection):
            # List needs to be flattened
            self.add(list(flatten(feature._feature_desc_dict.values())))
        else:
            raise TypeError(f&#34;type: {type(feature)} is not supported - {feature}&#34;)</code></pre>
</details>
</dd>
<dt id="tsflex.features.FeatureCollection.calculate"><code class="name flex">
<span>def <span class="ident">calculate</span></span>(<span>self, data, return_df=False, window_idx='end', approve_sparsity=False, show_progress=False, logging_file_path=None, n_jobs=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate features on the passed data.</p>
<h2 id="notes">Notes</h2>
<ul>
<li>The (column-)names of the series in <code>data</code> represent the names in the keys.</li>
<li>If a <code>logging_file_path</code> is provided, the execution (time) info can be
retrieved by calling <code><a title="tsflex.features.logger.get_feature_logs" href="logger.html#tsflex.features.logger.get_feature_logs">get_feature_logs()</a>(logging_file_path)</code>.
Be aware that the <code>logging_file_path</code> gets cleared before the logger pushes
logged messages. Hence, one should use a separate logging file for each
constructed processing and feature instance with this library.</li>
</ul>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>Union[pd.Series, pd.DataFrame, List[Union[pd.Series, pd.DataFrame]]]</code></dt>
<dd>
<p>Dataframe or Series or list thereof, with all the required data for the
feature calculation. </p>
<p><strong>Remark</strong>: each Series / DataFrame must have a <code>pd.DatetimeIndex</code>.
<strong>Remark</strong>: we assume that each name / column is unique.</p>
</dd>
<dt><strong><code>return_df</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether the output needs to be a dataframe list or a DataFrame, by default
False.
If <code>True</code> the output dataframes will be merged to a DataFrame with an outer
merge.</dd>
<dt><strong><code>window_idx</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The window's index position which will be used as index for the
feature_window aggregation. Must be either of: ['begin', 'middle', 'end'],
by default 'end'. All features in this collection will use the same
window_idx.</dd>
<dt><strong><code>approve_sparsity</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Bool indicating whether the user acknowledges that there may be sparsity
(i.e., irregularly sampled data), by default False.
If False and sparsity is observed, a warning is raised.</dd>
<dt><strong><code>show_progress</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If True, the progress will be shown with a progressbar, by default False.</dd>
<dt><strong><code>logging_file_path</code></strong> :&ensp;<code>Union[str, Path]</code>, optional</dt>
<dd>The file path where the logged messages are stored. If <code>None</code>, then no
logging <code>FileHandler</code> will be used and the logging messages are only pushed
to stdout. Otherwise, a logging <code>FileHandler</code> will write the logged messages
to the given file path.</dd>
<dt><strong><code>n_jobs</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>
<p>The number of processes used for the feature calculation. If <code>None</code>, then
the number returned by <code>os.cpu_count()</code> is used, by default None. </p>
<p>If n_jobs is either 0 or 1, the code will be executed sequentially without
creating a process pool. This is very useful when debugging, as the stack
trace will be more comprehensible.</p>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<ul>
<li>It takes on avg. <em>300ms</em> to schedule everything with
multiprocessing. So if your feature extraction code runs faster than
~1.5s, it might not be worth it to parallelize the process
(and thus better set the <code>n_jobs</code> to 0-1).</li>
<li>This method its memory peaks are significantly lower when executed
sequentially. Set the <code>n_jobs</code> to 0-1 if this matters.</li>
</ul>
</div>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Union[List[pd.DataFrame], pd.DataFrame]</code></dt>
<dd>The calculated features.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>KeyError</code></dt>
<dd>Raised when a required key is not found in <code>data</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate(
    self,
    data: Union[pd.Series, pd.DataFrame, List[Union[pd.Series, pd.DataFrame]]],
    return_df: Optional[bool] = False,
    window_idx: Optional[str] = &#34;end&#34;,
    approve_sparsity: Optional[bool] = False,
    show_progress: Optional[bool] = False,
    logging_file_path: Optional[Union[str, Path]] = None,
    n_jobs: Optional[int] = None,
) -&gt; Union[List[pd.DataFrame], pd.DataFrame]:
    &#34;&#34;&#34;Calculate features on the passed data.

    Notes
    ------
    * The (column-)names of the series in `data` represent the names in the keys.
    * If a `logging_file_path` is provided, the execution (time) info can be
      retrieved by calling `logger.get_feature_logs(logging_file_path)`.
      Be aware that the `logging_file_path` gets cleared before the logger pushes
      logged messages. Hence, one should use a separate logging file for each
      constructed processing and feature instance with this library.

    Parameters
    ----------
    data : Union[pd.Series, pd.DataFrame, List[Union[pd.Series, pd.DataFrame]]]
        Dataframe or Series or list thereof, with all the required data for the
        feature calculation. \n
        **Remark**: each Series / DataFrame must have a `pd.DatetimeIndex`.
        **Remark**: we assume that each name / column is unique.
    return_df : bool, optional
        Whether the output needs to be a dataframe list or a DataFrame, by default
        False.
        If `True` the output dataframes will be merged to a DataFrame with an outer
        merge.
    window_idx : str, optional
        The window&#39;s index position which will be used as index for the
        feature_window aggregation. Must be either of: [&#39;begin&#39;, &#39;middle&#39;, &#39;end&#39;],
        by default &#39;end&#39;. All features in this collection will use the same
        window_idx.
    approve_sparsity: bool, optional
        Bool indicating whether the user acknowledges that there may be sparsity
        (i.e., irregularly sampled data), by default False.
        If False and sparsity is observed, a warning is raised.
    show_progress: bool, optional
        If True, the progress will be shown with a progressbar, by default False.
    logging_file_path : Union[str, Path], optional
        The file path where the logged messages are stored. If `None`, then no
        logging `FileHandler` will be used and the logging messages are only pushed
        to stdout. Otherwise, a logging `FileHandler` will write the logged messages
        to the given file path.
    n_jobs : int, optional
        The number of processes used for the feature calculation. If `None`, then
        the number returned by `os.cpu_count()` is used, by default None. \n
        If n_jobs is either 0 or 1, the code will be executed sequentially without
        creating a process pool. This is very useful when debugging, as the stack
        trace will be more comprehensible.

        .. tip::
            * It takes on avg. _300ms_ to schedule everything with
              multiprocessing. So if your feature extraction code runs faster than
              ~1.5s, it might not be worth it to parallelize the process
              (and thus better set the `n_jobs` to 0-1).
            * This method its memory peaks are significantly lower when executed
              sequentially. Set the `n_jobs` to 0-1 if this matters.

    Returns
    -------
    Union[List[pd.DataFrame], pd.DataFrame]
        The calculated features.

    Raises
    ------
    KeyError
        Raised when a required key is not found in `data`.

    &#34;&#34;&#34;
    # Delete other logging handlers
    delete_logging_handlers(logger)
    # Add logging handler (if path provided)
    if logging_file_path:
        add_logging_handler(logger, logging_file_path)

    # Convert the data to a series_dict
    series_dict: Dict[str, pd.Series] = {}
    for s in to_series_list(data):
        # Assert the assumptions we make!
        assert isinstance(s.index, pd.DatetimeIndex)
        assert s.index.is_monotonic_increasing

        if s.name in self.get_required_series():
            series_dict[str(s.name)] = s

    calculated_feature_list: List[pd.DataFrame] = []
    
    # Note: this variable has a global scope so this is shared in multiprocessing
    global get_stroll_func
    get_stroll_func = self._stroll_feat_generator(
        series_dict, window_idx, approve_sparsity
    )
    nb_stroll_funcs = self._get_stroll_feat_length()

    if n_jobs is None: 
        n_jobs = os.cpu_count()
    n_jobs = min(n_jobs, nb_stroll_funcs)

    if n_jobs in [0, 1]:
        idxs = range(nb_stroll_funcs)
        if show_progress:
            idxs = tqdm(idxs)
        calculated_feature_list = [self._executor(idx) for idx in idxs]
    else:
        # https://pathos.readthedocs.io/en/latest/pathos.html#usage
        with ProcessPool(nodes=n_jobs, source=True) as pool:
            results = pool.uimap(
                self._executor,
                range(nb_stroll_funcs),
            )
            if show_progress:
                results = tqdm(results, total=self._get_stroll_feat_length())
            calculated_feature_list = [f for f in results]
            # Close &amp; join - see: https://github.com/uqfoundation/pathos/issues/131
            pool.close()
            pool.join()
            # Clear because: https://github.com/uqfoundation/pathos/issues/111
            pool.clear()

    if return_df:
        return pd.concat(calculated_feature_list, axis=1, join=&#34;outer&#34;, copy=False)
    else:
        return calculated_feature_list</code></pre>
</details>
</dd>
<dt id="tsflex.features.FeatureCollection.serialize"><code class="name flex">
<span>def <span class="ident">serialize</span></span>(<span>self, file_path)</span>
</code></dt>
<dd>
<div class="desc"><p>Serialize this <code><a title="tsflex.features.FeatureCollection" href="#tsflex.features.FeatureCollection">FeatureCollection</a></code> instance.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>file_path</code></strong> :&ensp;<code>Union[str, Path]</code></dt>
<dd>The path where the <code><a title="tsflex.features.FeatureCollection" href="#tsflex.features.FeatureCollection">FeatureCollection</a></code> will be serialized.</dd>
</dl>
<h2 id="notes">Notes</h2>
<ul>
<li>As we use <a href="https://github.com/uqfoundation/dill" target="_blank">Dill</a> to
serialize the files, we can <strong>also serialize functions which are defined in
the local scope, like lambdas.</strong></li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def serialize(self, file_path: Union[str, Path]):
    &#34;&#34;&#34;Serialize this `FeatureCollection` instance.

    Parameters
    ----------
    file_path : Union[str, Path]
        The path where the `FeatureCollection` will be serialized.

    Notes
    -----
    * As we use [Dill](https://github.com/uqfoundation/dill){:target=&#34;_blank&#34;} to
      serialize the files, we can **also serialize functions which are defined in
      the local scope, like lambdas.**

    &#34;&#34;&#34;
    with open(file_path, &#34;wb&#34;) as f:
        dill.dump(self, f, recurse=True)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="tsflex.features.NumpyFuncWrapper"><code class="flex name class">
<span>class <span class="ident">NumpyFuncWrapper</span></span>
<span>(</span><span>func, output_names=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Numpy function wrapper.</p>
<p>A Numpy function wrapper which takes a numpy array as input and returns a numpy
array. It also defines the names of the function outputs.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>func</code></strong> :&ensp;<code>Callable</code></dt>
<dd>The wrapped function.</dd>
<dt><strong><code>output_names</code></strong> :&ensp;<code>Union[List[str], str]</code>, optional</dt>
<dd>The name of the outputs of the function, by default None.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>Raised when the <code>output_names</code> cannot be set.</dd>
</dl>
<p>Create NumpyFuncWrapper instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NumpyFuncWrapper(FrozenClass):  # TODO: waarom niet gewoon FuncWrapper?
    &#34;&#34;&#34;Numpy function wrapper.

    A Numpy function wrapper which takes a numpy array as input and returns a numpy
    array. It also defines the names of the function outputs.

    Parameters
    ----------
    func : Callable
        The wrapped function.
    output_names : Union[List[str], str], optional
        The name of the outputs of the function, by default None.

    Raises
    ------
    TypeError
        Raised when the `output_names` cannot be set.

    &#34;&#34;&#34;

    def __init__(
        self, func: Callable, output_names: Union[List[str], str] = None, **kwargs
    ):
        &#34;&#34;&#34;Create NumpyFuncWrapper instance.&#34;&#34;&#34;
        self.func = func
        self.kwargs: dict = kwargs

        if isinstance(output_names, list):
            self.output_names = output_names
        elif isinstance(output_names, str):
            self.output_names = [output_names]
        elif not output_names:
            self.output_names = [self.func.__name__]
        else:
            raise TypeError(f&#34;`output_names` is unexpected type {type(output_names)}&#34;)

        self._freeze()

    def __repr__(self) -&gt; str:
        &#34;&#34;&#34;Return repr string.&#34;&#34;&#34;
        return (
            f&#34;{self.__class__.__name__}({self.func.__name__}, {self.output_names},&#34;
            f&#34; {self.kwargs})&#34;
        )

    def __call__(self, *series: np.ndarray) -&gt; Any:
        &#34;&#34;&#34;Call wrapped function with passed data.

        Parameters
        ---------
        *series : np.ndarray
            The (multiple) input series for the function.

        Returns
        -------
        Any
            The function its output for the passed series.

        &#34;&#34;&#34;
        return self.func(*series, **self.kwargs)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>tsflex.utils.classes.FrozenClass</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="tsflex.features.NumpyFuncWrapper.__call__"><code class="name flex">
<span>def <span class="ident">__call__</span></span>(<span>self, *series)</span>
</code></dt>
<dd>
<div class="desc"><p>Call wrapped function with passed data.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>*series</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>The (multiple) input series for the function.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Any</code></dt>
<dd>The function its output for the passed series.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __call__(self, *series: np.ndarray) -&gt; Any:
    &#34;&#34;&#34;Call wrapped function with passed data.

    Parameters
    ---------
    *series : np.ndarray
        The (multiple) input series for the function.

    Returns
    -------
    Any
        The function its output for the passed series.

    &#34;&#34;&#34;
    return self.func(*series, **self.kwargs)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<div style="text-align: center">
<a class="homelink" rel="home" title="tsflex home" href="/tsflex/">
<img src="https://cdn.discordapp.com/attachments/372491075153166338/852904976560554094/logo.png"
alt="logo should be displayed here" style="width: 100%;"></a>
</div>
</header>
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#feature-extraction-guide">Feature extraction guide</a><ul>
<li><a href="#working-example">Working example ‚úÖ</a></li>
<li><a href="#getting-started">Getting started üöÄ</a><ul>
<li><a href="#components">Components</a></li>
<li><a href="#feature-functions">Feature functions</a></li>
<li><a href="#multiple-feature-descriptors">Multiple feature descriptors</a></li>
<li><a href="#output-format">Output format</a></li>
</ul>
</li>
<li><a href="#limitations">Limitations ‚ö†Ô∏è</a></li>
<li><a href="#important-notes">Important notes üì¢</a></li>
<li><a href="#advanced-usage">Advanced usage üëÄ</a><ul>
<li><a href="#versatile-functions">Versatile functions</a></li>
<li><a href="#multivariate-data">Multivariate-data</a></li>
<li><a href="#multiple-time-series">Multiple time series</a></li>
<li><a href="#irregularly-sampled-data">Irregularly sampled data</a></li>
<li><a href="#logging">Logging</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="tsflex" href="../index.html">tsflex</a></code></li>
</ul>
</li>
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="tsflex.features.feature" href="feature.html">tsflex.features.feature</a></code></li>
<li><code><a title="tsflex.features.feature_collection" href="feature_collection.html">tsflex.features.feature_collection</a></code></li>
<li><code><a title="tsflex.features.function_wrapper" href="function_wrapper.html">tsflex.features.function_wrapper</a></code></li>
<li><code><a title="tsflex.features.logger" href="logger.html">tsflex.features.logger</a></code></li>
<li><code><a title="tsflex.features.strided_rolling" href="strided_rolling.html">tsflex.features.strided_rolling</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="tsflex.features.get_feature_logs" href="#tsflex.features.get_feature_logs">get_feature_logs</a></code></li>
<li><code><a title="tsflex.features.get_function_stats" href="#tsflex.features.get_function_stats">get_function_stats</a></code></li>
<li><code><a title="tsflex.features.get_series_names_stats" href="#tsflex.features.get_series_names_stats">get_series_names_stats</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="tsflex.features.FeatureDescriptor" href="#tsflex.features.FeatureDescriptor">FeatureDescriptor</a></code></h4>
<ul class="">
<li><code><a title="tsflex.features.FeatureDescriptor.get_required_series" href="#tsflex.features.FeatureDescriptor.get_required_series">get_required_series</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tsflex.features.MultipleFeatureDescriptors" href="#tsflex.features.MultipleFeatureDescriptors">MultipleFeatureDescriptors</a></code></h4>
</li>
<li>
<h4><code><a title="tsflex.features.FeatureCollection" href="#tsflex.features.FeatureCollection">FeatureCollection</a></code></h4>
<ul class="">
<li><code><a title="tsflex.features.FeatureCollection.get_required_series" href="#tsflex.features.FeatureCollection.get_required_series">get_required_series</a></code></li>
<li><code><a title="tsflex.features.FeatureCollection.add" href="#tsflex.features.FeatureCollection.add">add</a></code></li>
<li><code><a title="tsflex.features.FeatureCollection.calculate" href="#tsflex.features.FeatureCollection.calculate">calculate</a></code></li>
<li><code><a title="tsflex.features.FeatureCollection.serialize" href="#tsflex.features.FeatureCollection.serialize">serialize</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tsflex.features.NumpyFuncWrapper" href="#tsflex.features.NumpyFuncWrapper">NumpyFuncWrapper</a></code></h4>
<ul class="">
<li><code><a title="tsflex.features.NumpyFuncWrapper.__call__" href="#tsflex.features.NumpyFuncWrapper.__call__">__call__</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>