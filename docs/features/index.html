<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>tsflex.features API documentation</title>
<meta name="description" content="Feature extraction submodule …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/foundation.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em;padding-left:1em;padding-right:1em}button{display:none}#sidebar{padding:3px;max-width:20em;overflow:hidden;min-width:19.8em}#sidebar > *:last-child{margin-bottom:1cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;border-top:1px solid #ddd;text-align:right}#footer p{}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f1f3f9;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:0.5em;padding:0px}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;max_width:100%;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.info{background:#edfcf4}.admonition.note,.admonition.important{background:#ebf3ff}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#edfcf4}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#ffddcc}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:850px){.sidebar_container{display:flex;transition:0.75s ease}.sidebar_small{width:0;margin:0;padding:0}.hide_content{display:none}button{display:initial;float:left;position:sticky;border:none;height:5ch;width:5ch;border-radius:50%;box-shadow:0px 1px 4px 1px rgba(0,0,0,.2);top:5%;left:100%;transform:translateX(-50%);cursor:pointer}#sidebar{width:25%;height:100vh;overflow:auto;position:sticky;top:0;transition:0.75s ease}#index_button_img{opacity:0.65}#content{max-width:105ch;padding:2em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1em;padding-right:0.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-212611910-1"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-212611910-1');
</script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
<link rel="icon" href="https://media.discordapp.net/attachments/372491075153166338/852906324417445908/icon.png">
</head>
<body>
<main>
<article id="content">
<button id="index_button_button"><img id="index_button_img"
src="https://image.flaticon.com/icons/png/512/56/56763.png"
alt="" width="33" height="25"></button>
<header>
<h1 class="title">Module <code>tsflex.features</code></h1>
</header>
<section id="section-intro">
<p>Feature extraction submodule.</p>
<h1 id="feature-extraction-guide">Feature extraction guide</h1>
<p>The following sections will explain the feature extraction module in detail.</p>
<div style="text-align: center;">
<h3><b><a href="#header-submodules">Jump to API reference</a></b></h3>
</div>
<p><br></p>
<h2 id="working-example">Working example ✅</h2>
<p><em>tsflex</em> is built to be intuitive, so we encourage you to copy-paste this code and toy with some parameters! <br></p>
<p>This executable example creates a feature-collection that contains 2 features (skewness and minimum). Note that <em>tsflex</em> does not make any assumptions about the sampling rate of the time-series data.</p>
<pre><code class="language-python">import pandas as pd; import scipy.stats as ss; import numpy as np
from tsflex.features import FeatureDescriptor, FeatureCollection, FuncWrapper

# 1. -------- Get your time-indexed data --------
# Data contains 1 column; [&quot;TMP&quot;]
url = &quot;https://github.com/predict-idlab/tsflex/raw/main/examples/data/empatica/&quot;
data = pd.read_parquet(url + &quot;tmp.parquet&quot;).set_index(&quot;timestamp&quot;)

# 2 -------- Construct your feature collection --------
fc = FeatureCollection(
    feature_descriptors=[
        FeatureDescriptor(
            function=FuncWrapper(func=ss.skew, output_names=&quot;skew&quot;),
            series_name=&quot;TMP&quot;, 
            window=&quot;5min&quot;, stride=&quot;2.5min&quot;,
        )
    ]
)
# -- 2.1. Add features to your feature collection
# NOTE: tsflex allows features to have different windows and strides
fc.add(FeatureDescriptor(np.min, &quot;TMP&quot;, '2.5min', '2.5min'))

# 3 -------- Calculate features --------
fc.calculate(data=data, return_df=True)  # which outputs:
</code></pre>
<table>
<thead>
<tr>
<th style="text-align: left;">timestamp</th>
<th style="text-align: right;">TMP__amin__w=1m_s=30s</th>
<th style="text-align: right;">TMP__skew__w=2m_s=1m</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">2017-06-13 14:23:13+02:00</td>
<td style="text-align: right;">27.37</td>
<td style="text-align: right;">nan</td>
</tr>
<tr>
<td style="text-align: left;">2017-06-13 14:23:43+02:00</td>
<td style="text-align: right;">27.37</td>
<td style="text-align: right;">nan</td>
</tr>
<tr>
<td style="text-align: left;">2017-06-13 14:24:13+02:00</td>
<td style="text-align: right;">27.43</td>
<td style="text-align: right;">10.8159</td>
</tr>
<tr>
<td style="text-align: left;">2017-06-13 14:24:43+02:00</td>
<td style="text-align: right;">27.81</td>
<td style="text-align: right;">nan</td>
</tr>
<tr>
<td style="text-align: left;">2017-06-13 14:25:13+02:00</td>
<td style="text-align: right;">28.23</td>
<td style="text-align: right;">-0.0327893</td>
</tr>
<tr>
<td style="text-align: left;">&hellip;</td>
<td style="text-align: right;">&hellip;</td>
<td style="text-align: right;">&hellip;</td>
</tr>
<tr>
<td style="text-align: left;"><br></td>
<td style="text-align: right;"></td>
<td style="text-align: right;"></td>
</tr>
</tbody>
</table>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>More advanced feature-extraction examples can be found <a href="https://github.com/predict-idlab/tsflex/tree/main/examples">in these example notebooks</a></p>
</div>
<p><br></p>
<h2 id="getting-started">Getting started 🚀</h2>
<p>The feature-extraction functionality of <em>tsflex</em> is provided by a <code><a title="tsflex.features.FeatureCollection" href="#tsflex.features.FeatureCollection">FeatureCollection</a></code> that contains <code><a title="tsflex.features.FeatureDescriptor" href="#tsflex.features.FeatureDescriptor">FeatureDescriptor</a></code>s. The features are calculated (in a parallel manner) on the data that is passed to the feature collection.</p>
<h3 id="components">Components</h3>
<p><img alt="features uml" src="https://raw.githubusercontent.com/predict-idlab/tsflex/main/docs/_static/features_uml.png"></p>
<p>As shown above, there are 3 relevant classes for feature-extraction.</p>
<ol>
<li><a href="/tsflex/features/#tsflex.features.FeatureCollection">FeatureCollection</a>: serves as a registry, withholding the to-be-calculated <em>features</em></li>
<li><a href="/tsflex/features/#tsflex.features.FeatureDescriptor">FeatureDescriptor</a>: an instance of this class describes a <em>feature</em>.
<br>Features are defined by:<ul>
<li><code>series_name</code>: the names of the input series on which the feature-function will operate</li>
<li><code>function</code>: the <em>Callable</em> feature-function - e.g. <em>np.mean</em></li>
<li><code>window</code>: the <em>sample</em> or <em>time-based</em> window -
e.g. <em>200</em> or <em>"2days"</em></li>
<li><code>stride</code>: the <em>sample</em> or <em>time-based</em> stride - e.g. <em>15</em> or <em>"1hour"</em></li>
</ul>
</li>
<li><a href="/tsflex/features/#tsflex.features.FuncWrapper">FuncWrapper</a>: wraps <em>Callable</em> feature functions, and is intended for feature function configuration.
<br>FuncWrappers are defined by:<ul>
<li><code>func</code>: The wrapped feature-function</li>
<li><code>output_names</code>: set custom and/or multiple feature output names</li>
<li><code>input_type</code>: define the feature its datatype; e.g., a pd.Series or np.array</li>
<li><em>**kwargs</em>: additional keyword argument which are passed to <code>func</code></li>
</ul>
</li>
</ol>
<p>The snippet below shows how the <code><a title="tsflex.features.FeatureCollection" href="#tsflex.features.FeatureCollection">FeatureCollection</a></code> &amp; <code><a title="tsflex.features.FeatureDescriptor" href="#tsflex.features.FeatureDescriptor">FeatureDescriptor</a></code> components work together:</p>
<pre><code class="language-python">import numpy as np; import scipy.stats as ss
from tsflex.features import FeatureDescriptor, FeatureCollection

# The FeatureCollection takes a List[FeatureDescriptor] as input
# There is no need for using a FuncWrapper when dealing with simple feature functions
fc = FeatureCollection(feature_descriptors=[
        FeatureDescriptor(np.mean, &quot;series_a&quot;, &quot;1hour&quot;, &quot;15min&quot;),
        FeatureDescriptor(ss.skew, &quot;series_b&quot;, &quot;3hours&quot;, &quot;5min&quot;)
    ]
)

# We can still add features after instantiating.
fc.add(features=[FeatureDescriptor(np.std, &quot;series_a&quot;, &quot;1hour&quot;, &quot;15min&quot;)])

# Calculate the features
fc.calculate(...)
</code></pre>
<h3 id="feature-functions">Feature functions</h3>
<p>A feature function needs to match this prototype:</p>
<pre><code>function(*series: Union[np.ndarray, pd.Series], **kwargs)
    -&gt; Union[Any, List[Any]]
</code></pre>
<p>Hence, feature functions should take one (or multiple) arrays as first input. This can be followed by some keyword arguments.<br>
The output of a feature function can be rather versatile (e.g., a float, integer, string, bool, &hellip; or a list thereof). <br><br>
Note that the feature function may also take more than one series as input. In this case, the feature function should be wrapped in a <code><a title="tsflex.features.FuncWrapper" href="#tsflex.features.FuncWrapper">FuncWrapper</a></code>, with the <code>input_type</code> argument set to <code>pd.Series</code>.</p>
<p>In the <a href="#advanced-usage">advanced usage</a> section, more info is given on these feature-function.</p>
<h3 id="multiple-feature-descriptors">Multiple feature descriptors</h3>
<p>Sometimes it can get overly verbose when the same feature is shared over multiple series, windows and/or strides. To solve this problem, we introduce the <code><a title="tsflex.features.MultipleFeatureDescriptors" href="#tsflex.features.MultipleFeatureDescriptors">MultipleFeatureDescriptors</a></code>. This component allows to <strong>create multiple feature descriptors for all</strong> the <code>function - series_name(s) - window - stride</code> <strong>combinations</strong>.</p>
<p>As shown in the example below, a <code><a title="tsflex.features.MultipleFeatureDescriptors" href="#tsflex.features.MultipleFeatureDescriptors">MultipleFeatureDescriptors</a></code> instance can be added a <code><a title="tsflex.features.FeatureCollection" href="#tsflex.features.FeatureCollection">FeatureCollection</a></code>.</p>
<pre><code class="language-python">import numpy as np; import scipy.stats as ss
from tsflex.features import FeatureDescriptor, FeatureCollection
from tsflex.features import MultipleFeatureDescriptors

# There is no need for using a FuncWrapper when dealing with simple feature functions
fc = FeatureCollection(feature_descriptors=[
        FeatureDescriptor(np.mean, &quot;series_a&quot;, &quot;1hour&quot;, &quot;15min&quot;),
        FeatureDescriptor(ss.skew, &quot;series_b&quot;, &quot;3hours&quot;, &quot;5min&quot;),
        # Expands to a feature-descriptor list, withholding the combination of all 
        # The feature-window-stride arguments above.
        MultipleFeatureDescriptors(
            functions=[np.min, np.max, np.std, ss.skew],
            series_names=[&quot;series_a&quot;, &quot;series_b&quot;, &quot;series_c&quot;],
            windows=[&quot;5min&quot;, &quot;15min&quot;],
            strides=[&quot;1min&quot;,&quot;2min&quot;,&quot;3min&quot;]
        )
    ]
)

# Calculate the features
fc.calculate(...)
</code></pre>
<h3 id="output-format">Output format</h3>
<p>The output of the <code><a title="tsflex.features.FeatureCollection" href="#tsflex.features.FeatureCollection">FeatureCollection</a></code> its <code><a title="tsflex.features.FeatureCollection.calculate" href="#tsflex.features.FeatureCollection.calculate">.calculate()</a></code> is a (list of) <strong><code>sequence-indexed pd.DataFrames</code></strong> with column names:</p>
<blockquote>
<p><strong><code>&lt;SERIES-NAME&gt;__&lt;FEAT-NAME&gt;__w=&lt;WINDOW&gt;__s=&lt;STRIDE&gt;</code></strong>.</p>
</blockquote>
<p>The column-name for the first feature defined in the snippet above will thus be <code>series_a__std__w=1h__s=15m</code>.</p>
<p>When the windows and strides are defined in a sample based-manner (which is mandatory for non datetime-indexed data), a possible output column would be <code>series_a__std__w=100_s=15</code>, where the window and stride are defined in samples and thus not in time-strings.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>You can find more information about the <strong>input data-formats</strong> in <a href="/tsflex/#data-formats">this section</a> and read more about the (obvious) <strong>limitations</strong> in the next section.</p>
</div>
<p><br></p>
<h2 id="limitations">Limitations ⚠️</h2>
<p>It is important to note that there a still some, albeit logical, <strong>limitations</strong> regarding the supported <a href="/tsflex/#data-formats">data format</a>.</p>
<p>These limitations are:</p>
<ol>
<li>Each <a href="/tsflex/#data-formats"><code>ts</code></a> must be in the <strong><span style="color:darkred">flat/wide</span> data format</strong> and they all need to have the <strong><span style="color:darkred">same sequence index dtype</span></strong>, which needs to be <strong>sortable</strong>.<ul>
<li>It just doesn't make sense to have a mix of different sequence index dtypes.<br>
Imagine a FeatureCollection to which a <code>ts</code> with a <code>pd.DatetimeIndex</code> is passed, but a <code>ts</code> with a <code>pd.RangeIndex</code> is also passed. Both indexes aren't comparable, which thus is counterintuitive.</li>
</ul>
</li>
<li>tsflex has <strong>no support</strong> for <b style="color:darkred">multi-indexes &amp; multi-columns</b></li>
<li>tsflex assumes that each <code>ts</code> has a unique name. Hence <b style="color:darkred">no duplicate</b> <code>ts</code> <b style="color:darkred">names</b> are allowed<ul>
<li><strong>Countermeasure</strong>: rename your <code>ts</code></li>
</ul>
</li>
</ol>
<p><br></p>
<h2 id="important-notes">Important notes 📢</h2>
<p>We support various data-types. e.g. (np.float32, string-data, time-based data). However, it is the end-users responsibility to use a function which interplays nicely with the data its format.</p>
<p><br></p>
<h2 id="advanced-usage">Advanced usage 👀</h2>
<p>Also take a look at the <code><a title="tsflex.features.FeatureCollection.reduce" href="#tsflex.features.FeatureCollection.reduce">.reduce()</a></code> and <code><a title="tsflex.features.FeatureCollection.serialize" href="#tsflex.features.FeatureCollection.serialize">.serialize()</a></code> methods.</p>
<h3 id="versatile-functions">Versatile functions</h3>
<p>As <a href="#feature-functions">explained above</a> <em>tsflex</em> is rather versatile in terms of function input and output.</p>
<p><em>tsflex</em> does not just allow <code>one-to-one</code> processing functions, but also <code>many-to-one</code>, <code>one-to-many</code>, and <code>many-to-many</code> functions are supported in a convenient way:</p>
<!--
- `one-to-one`; the **feature function** should
- take a single series as input
- output a single value
The function should (usually) not be wrapped in a <code><a title="tsflex.features.FuncWrapper" href="#tsflex.features.FuncWrapper">FuncWrapper</a></code>.
Example
<pre><code class="language-python">def abs_sum(s: np.array) -&gt; float:
    return np.sum(np.abs(s))

fd = FeatureDescriptor(
    abs_sum, series_name=&quot;series_1&quot;, window=&quot;5m&quot;, stride=&quot;2m30s&quot;,
)
</code></pre>
-->
<ul>
<li>
<p><code>many-to-one</code>; the <strong>feature function</strong> should</p>
<ul>
<li>take multiple series as input</li>
<li>output a single value</li>
</ul>
<p>The function should (usually) not be wrapped in a <code><a title="tsflex.features.FuncWrapper" href="#tsflex.features.FuncWrapper">FuncWrapper</a></code>. <br>
Note that now the <code>series_name</code> argument requires a tuple of the ordered input series names.</p>
<p>Example:</p>
</li>
</ul>
<pre><code class="language-python">def abs_sum_diff(s1: np.array, s2: np.array) -&gt; float:
    min_len = min(len(s1), len(s2))
    return np.sum(np.abs(s1[:min_len] - s2[:min_len]))

fd = FeatureDescriptor(
    abs_sum_diff, series_name=(&quot;series_1&quot;, &quot;series_2&quot;), 
    window=&quot;5m&quot;, stride=&quot;2m30s&quot;,
)
</code></pre>
<ul>
<li>
<p><code>one-to-many</code>; the <strong>feature function</strong> should</p>
<ul>
<li>take a single series as input</li>
<li>output multiple values</li>
</ul>
<p>The function should be wrapped in a <code><a title="tsflex.features.FuncWrapper" href="#tsflex.features.FuncWrapper">FuncWrapper</a></code> to log its multiple output names.</p>
<p>Example:</p>
</li>
</ul>
<pre><code class="language-python">def abs_stats(s: np.array) -&gt; Tuple[float]:
    s_abs = np.abs(s)
    return np.min(s_abs), np.max(s_abs), np.mean(s_abs), np.std(s_abs)

output_names = [&quot;abs_min&quot;, &quot;abs_max&quot;, &quot;abs_mean&quot;, &quot;abs_std&quot;]
fd = FeatureDescriptor(
    FuncWrapper(abs_stats, output_names=output_names),
    series_name=&quot;series_1&quot;, window=&quot;5m&quot;, stride=&quot;2m30s&quot;,
)
</code></pre>
<ul>
<li>
<p><code>many-to-many</code>; the <strong>feature function</strong> should</p>
<ul>
<li>take multiple series as input</li>
<li>output multiple values</li>
</ul>
<p>The function should be wrapped in a <code><a title="tsflex.features.FuncWrapper" href="#tsflex.features.FuncWrapper">FuncWrapper</a></code> to log its multiple output names.</p>
<p>Example:</p>
</li>
</ul>
<pre><code class="language-python">def abs_stats_diff(s1: np.array, s2: np.array) -&gt; Tuple[float]:
    min_len = min(len(s1), len(s2))
    s_abs_diff = np.sum(np.abs(s1[:min_len] - s2[:min_len]))
    return np.min(s_abs_diff), np.max(s_abs_diff), np.mean(s_abs_diff)

output_names = [&quot;abs_diff_min&quot;, &quot;abs_diff_max&quot;, &quot;abs_diff_mean&quot;]
fd = FeatureDescriptor(
    FuncWrapper(abs_stats_diff, output_names=output_names),
    series_name=(&quot;series_1&quot;, &quot;series_2&quot;), window=&quot;5m&quot;, stride=&quot;2m30s&quot;,
)
</code></pre>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>As visible in the <a href="#feature-functions">feature function prototype</a>, both <code>np.array</code> and <code>pd.Series</code> are supported function input types.
If your feature function requires <code>pd.Series</code> as input (instead of the default <code>np.array</code>), the function should be wrapped in a <code><a title="tsflex.features.FuncWrapper" href="#tsflex.features.FuncWrapper">FuncWrapper</a></code> with the <code>input_type</code> argument set to <code>pd.Series</code>.</p>
</div>
<p>An example of a function that leverages the pd.Series datatype:</p>
<pre><code class="language-python">def linear_trend_timewise(s: pd.Series):
    # Get differences between each timestamp and the first timestamp in hour float
    # Then convert to hours and reshape for linear regression
    times_hours = np.asarray((s.index - s.index[0]).total_seconds() / 3600)
    linReg = linregress(times_hours, s.values)
    return linReg.slope, linReg.intercept, linReg.rvalue

fd = FeatureDescriptor(
     FuncWrapper(
        linear_trend_timewise,
        [&quot;twise_regr_slope&quot;, &quot;twise_regr_intercept&quot;, &quot;twise_regr_r_value&quot;],
        input_type=pd.Series, 
    ),
)
</code></pre>
<!-- TODO: review Jeroen! -->
<h3 id="multivariate-data">Multivariate-data</h3>
<p>There are no assumptions made about the <code>data</code> its <code>sequence-ranges</code>. However, the end-user must take some things in consideration.</p>
<ul>
<li>By using the <code>bound_method</code> argument of <code><a title="tsflex.features.FeatureCollection.calculate" href="#tsflex.features.FeatureCollection.calculate">.calculate()</a></code>, the end-user can specify whether the "inner" or "outer" data-bounds will be used for generating the slice-ranges.</li>
<li>All <code>ts</code> must-have the same data-index dtype. this makes them comparable and allows for generating same-range slices on multivariate data.</li>
</ul>
<h3 id="irregularly-sampled-data">Irregularly sampled data</h3>
<p>Strided-rolling feature extraction on irregularly sampled data results in varying feature-segment sizes.<br></p>
<p>When using multivariate data, with either different sample rates or with an irregular data-rate, <span style="color:darkred">you cannot make the assumption that all windows will have the same length</span>. Your feature extraction method should thus be:</p>
<blockquote>
<ul>
<li>robust for varying length windows</li>
<li>robust for (possible) empty windows</li>
</ul>
</blockquote>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>For conveniently creating such <strong>robust features</strong> we suggest using the <a href="integrations#tsflex.features.integrations.make_robust"><code>make_robust</code></a> function.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A <code>warning</code> will be raised when irregular sampled data is observed. <br>
In order to avoid this warning, the user should explicitly approve that there may be sparsity in the data by setting the <strong><code>approve_sparsity</code></strong> flag to True in the <code><a title="tsflex.features.FeatureCollection.calculate" href="#tsflex.features.FeatureCollection.calculate">.calculate()</a></code> method.</p>
</div>
<h3 id="logging">Logging</h3>
<p>When a <code>logging_file_path</code> is passed to the <code><a title="tsflex.features.FeatureCollection" href="#tsflex.features.FeatureCollection">FeatureCollection</a></code> its <code><a title="tsflex.features.FeatureCollection.calculate" href="#tsflex.features.FeatureCollection.calculate">.calculate()</a></code> method, the execution times of the feature functions will be logged.</p>
<p>This is especially useful to identify which feature functions take a long time to compute.</p>
<p><a href="#tsflex.features.get_feature_logs">More info about logging</a>.</p>
<p><br></p>
<hr>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Feature extraction submodule.

.. include:: ../../docs/pdoc_include/features.md

&#34;&#34;&#34;

__author__ = &#34;Jonas Van Der Donckt, Jeroen Van Der Donckt, Emiel Deprost&#34;

from .. import __pdoc__
from .feature import FeatureDescriptor, MultipleFeatureDescriptors
from .feature_collection import FeatureCollection
from .function_wrapper import FuncWrapper
from .logger import get_feature_logs, get_function_stats, get_series_names_stats
from .segmenter import StridedRollingFactory

__pdoc__[&#34;FuncWrapper.__call__&#34;] = True

__all__ = [
    &#34;FeatureDescriptor&#34;,
    &#34;MultipleFeatureDescriptors&#34;,
    &#34;FeatureCollection&#34;,
    &#34;FuncWrapper&#34;,
    &#34;StridedRollingFactory&#34;,
    &#34;get_feature_logs&#34;,
    &#34;get_function_stats&#34;,
    &#34;get_series_names_stats&#34;,
]</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">API reference of <code>tsflex.features</code></h2>
<dl>
<dt><code class="name"><a title="tsflex.features.feature" href="feature.html">.feature</a></code></dt>
<dd>
<div class="desc"><p>FeatureDescriptor and MultipleFeatureDescriptors class for creating time-series
features.</p></div>
</dd>
<dt><code class="name"><a title="tsflex.features.feature_collection" href="feature_collection.html">.feature_collection</a></code></dt>
<dd>
<div class="desc"><p>FeatureCollection class for bookkeeping and calculation of time-series features …</p></div>
</dd>
<dt><code class="name"><a title="tsflex.features.function_wrapper" href="function_wrapper.html">.function_wrapper</a></code></dt>
<dd>
<div class="desc"><p>FuncWrapper class for object-oriented representation of a function.</p></div>
</dd>
<dt><code class="name"><a title="tsflex.features.integrations" href="integrations.html">.integrations</a></code></dt>
<dd>
<div class="desc"><p>Wrappers for seamless integration of feature functions from other packages.</p></div>
</dd>
<dt><code class="name"><a title="tsflex.features.logger" href="logger.html">.logger</a></code></dt>
<dd>
<div class="desc"><p>Contains the used variables and functions to provide logging functionality …</p></div>
</dd>
<dt><code class="name"><a title="tsflex.features.segmenter" href="segmenter/index.html">.segmenter</a></code></dt>
<dd>
<div class="desc"><p>Series segmentation submodule.</p></div>
</dd>
<dt><code class="name"><a title="tsflex.features.utils" href="utils.html">.utils</a></code></dt>
<dd>
<div class="desc"><p>Utility functions for more convenient feature extraction.</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="tsflex.features.get_feature_logs"><code class="name flex">
<span>def <span class="ident">get_feature_logs</span></span>(<span>logging_file_path)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_feature_logs(logging_file_path: str) -&gt; pd.DataFrame:
    &#34;&#34;&#34;Get execution (time) info for each feature of a `FeatureCollection`.

    Parameters
    ----------
    logging_file_path: str
        The file path where the logged messages are stored. This is the file path that
        is passed to the `FeatureCollection` its `calculate` method.

    Returns
    -------
    pd.DataFrame
        A DataFrame with the features its function, input series names and
        (%) calculation duration.

    &#34;&#34;&#34;
    df = _parse_logging_execution_to_df(logging_file_path)
    df[&#34;duration&#34;] = pd.to_timedelta(df[&#34;duration&#34;], unit=&#34;s&#34;)
    return df</code></pre>
</details>
<div class="desc"><p>Get execution (time) info for each feature of a <code><a title="tsflex.features.FeatureCollection" href="#tsflex.features.FeatureCollection">FeatureCollection</a></code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>logging_file_path</code></strong> :&ensp;<code>str</code></dt>
<dd>The file path where the logged messages are stored. This is the file path that
is passed to the <code><a title="tsflex.features.FeatureCollection" href="#tsflex.features.FeatureCollection">FeatureCollection</a></code> its <code>calculate</code> method.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pd.DataFrame</code></dt>
<dd>A DataFrame with the features its function, input series names and
(%) calculation duration.</dd>
</dl></div>
</dd>
<dt id="tsflex.features.get_function_stats"><code class="name flex">
<span>def <span class="ident">get_function_stats</span></span>(<span>logging_file_path)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_function_stats(logging_file_path: str) -&gt; pd.DataFrame:
    &#34;&#34;&#34;Get execution (time) statistics for each function.

    Parameters
    ----------
    logging_file_path: str
        The file path where the logged messages are stored. This is the file path that
        is passed to the `FeatureCollection` its `calculate` method.

    Returns
    -------
    pd.DataFrame
        A DataFrame with for each function (i.e., `function-(window,stride)`)
        combination the mean (time), std (time), sum (time), sum (% time),
        mean (% time),and number of executions.

    &#34;&#34;&#34;
    df = _parse_logging_execution_to_df(logging_file_path)
    # Get the sorted functions in a list to use as key for sorting the groups
    sorted_funcs = (
        df.groupby([&#34;function&#34;])
        .agg({&#34;duration&#34;: [&#34;mean&#34;]})
        .sort_values(by=(&#34;duration&#34;, &#34;mean&#34;), ascending=True)
        .index.to_list()
    )

    def key_func(idx_level):
        if all(idx in sorted_funcs for idx in idx_level):
            return [sorted_funcs.index(idx) for idx in idx_level]
        return idx_level

    return (
        df.groupby([&#34;function&#34;, &#34;window&#34;, &#34;stride&#34;])
        .agg(
            {
                &#34;duration&#34;: [&#34;sum&#34;, &#34;mean&#34;, &#34;std&#34;, &#34;count&#34;],
                &#34;duration %&#34;: [&#34;sum&#34;, &#34;mean&#34;],
            }
        )
        .sort_index(key=key_func, ascending=False)
    )</code></pre>
</details>
<div class="desc"><p>Get execution (time) statistics for each function.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>logging_file_path</code></strong> :&ensp;<code>str</code></dt>
<dd>The file path where the logged messages are stored. This is the file path that
is passed to the <code><a title="tsflex.features.FeatureCollection" href="#tsflex.features.FeatureCollection">FeatureCollection</a></code> its <code>calculate</code> method.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pd.DataFrame</code></dt>
<dd>A DataFrame with for each function (i.e., <code>function-(window,stride)</code>)
combination the mean (time), std (time), sum (time), sum (% time),
mean (% time),and number of executions.</dd>
</dl></div>
</dd>
<dt id="tsflex.features.get_series_names_stats"><code class="name flex">
<span>def <span class="ident">get_series_names_stats</span></span>(<span>logging_file_path)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_series_names_stats(logging_file_path: str) -&gt; pd.DataFrame:
    &#34;&#34;&#34;Get execution (time) statistics for each `key-(window,stride)` combination.

    Parameters
    ----------
    logging_file_path: str
        The file path where the logged messages are stored. This is the file path that
        is passed to the `FeatureCollection` its `calculate` method.

    Returns
    -------
    pd.DataFrame
        A DataFrame with for each function the mean (time), std (time), sum (time),
        sum (% time), mean (% time), and number of executions.

    &#34;&#34;&#34;
    df = _parse_logging_execution_to_df(logging_file_path)
    return (
        df.groupby([&#34;series_names&#34;, &#34;window&#34;, &#34;stride&#34;])
        .agg(
            {
                &#34;duration&#34;: [&#34;sum&#34;, &#34;mean&#34;, &#34;std&#34;, &#34;count&#34;],
                &#34;duration %&#34;: [&#34;sum&#34;, &#34;mean&#34;],
            }
        )
        .sort_values(by=(&#34;duration&#34;, &#34;sum&#34;), ascending=False)
    )</code></pre>
</details>
<div class="desc"><p>Get execution (time) statistics for each <code>key-(window,stride)</code> combination.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>logging_file_path</code></strong> :&ensp;<code>str</code></dt>
<dd>The file path where the logged messages are stored. This is the file path that
is passed to the <code><a title="tsflex.features.FeatureCollection" href="#tsflex.features.FeatureCollection">FeatureCollection</a></code> its <code>calculate</code> method.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pd.DataFrame</code></dt>
<dd>A DataFrame with for each function the mean (time), std (time), sum (time),
sum (% time), mean (% time), and number of executions.</dd>
</dl></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="tsflex.features.FeatureDescriptor"><code class="flex name class">
<span>class <span class="ident">FeatureDescriptor</span></span>
<span>(</span><span>function, series_name, window=None, stride=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FeatureDescriptor(FrozenClass):
    &#34;&#34;&#34;A FeatureDescriptor object, containing all feature information.

    Parameters
    ----------
    function : Union[FuncWrapper, Callable]
        The function that calculates the feature(s).
        The prototype of the function should match: \n

            function(*series: Union[np.array, pd.Series])
                -&gt; Union[Any, List[Any]]

        Note that when the input type is ``pd.Series``, the function should be wrapped
          in a `FuncWrapper` with `input_type` = ``pd.Series``.

    series_name : Union[str, Tuple[str, ...]]
        The names of the series on which the feature function should be applied.
        This argument should match the `function` its input; \n
        * If `series_name` is a string (or tuple of a single string), then
            `function` should require just one series as input.
        * If `series_name` is a tuple of strings, then `function` should
            require `len(tuple)` series as input **and in exactly the same order**

    window : Union[float, str, pd.Timedelta], optional
        The window size. By default None. This argument supports multiple types: \n
        * If None, the `segment_start_idxs` and `segment_end_idxs` will need to be
          passed.
        * If the type is an `float` or an `int`, its value represents the series
            - its window **range** when a **non time-indexed** series is passed.
            - its window in **number of samples**, when a **time-indexed** series is
              passed (must then be and `int`)
        * If the window&#39;s type is a `pd.Timedelta`, the window size represents
          the window-time-range. The passed data **must have a time-index**.
        * If a `str`, it must represents a window-time-range-string. The **passed data
          must have a time-index**.
        .. Note::
            - When the `segment_start_idxs` and `segment_end_idxs` are both passed to
              the `FeatureCollection.calculate` method, this window argument is ignored.
              Note that this is the only case when it is allowed to pass None for the
              window argument.
            - When the window argument is None, than the stride argument should be None
              as well (as it makes no sense to pass a stride value when the window is
              None).

    stride : Union[float, str, pd.Timedelta, List[Union[float, str, pd.Timedelta]]], optional
        The stride size(s). By default None. This argument supports multiple types: \n
        * If None, the stride will need to be passed to `FeatureCollection.calculate`.
        * If the type is an `float` or an `int`, its value represents the series
            - its stride **range** when a **non time-indexed** series is passed.
            - the stride in **number of samples**, when a **time-indexed** series
              is passed (must then be and `int`)
        * If the stride&#39;s type is a `pd.Timedelta`, the stride size represents
          the stride-time delta. The passed data **must have a time-index**.
        * If a `str`, it must represent a stride-time-delta-string. The **passed data
          must have a time-index**. \n
        * If a `List[Union[float, str, pd.Timedelta]]`, then the set intersection,of the
          strides will be used (e.g., stride=[2,3] -&gt; index: 0, 2, 3, 4, 6, 8, 9, ...)
        .. Note::
            - The stride argument of `FeatureCollection.calculate` takes precedence over
              this value when set (i.e., not None value for `stride` passed to the
              `calculate` method).
            - The stride argument should be None when the window argument is None (as it
              makes no sense to pass a stride value when the window is None).

    .. Note::
        As described above, the `window-stride` argument can be sample-based (when using
        time-index series and int based arguments), but we
        do **not encourage** using this for `time-indexed` sequences. As we make the
        implicit assumption that the time-based data is sampled at a fixed frequency
        So only, if you&#39;re 100% sure that this is correct, you can safely use such
        arguments.

    Notes
    -----
    * The `window` and `stride` argument should be either **both** numeric or
      ``pd.Timedelta`` (depending on de index datatype) - when `stride` is not None.
    * For each `function` - `input`(-series) - `window` - stride combination, one needs
      to create a distinct `FeatureDescriptor`. Hence it is more convenient to
      create a `MultipleFeatureDescriptors` when `function` - `window` - `stride`
      **combinations** should be applied on various input-series (combinations).
    * When `function` takes **multiple series** (i.e., arguments) as **input**, these
      are joined (based on the index) before applying the function. If the indexes of
      these series are not exactly the same, it might occur that not all series have
      exactly the same length! Hence,  make sure that the `function` can deal with
      this!
    * For more information about the str-based time args, look into:
      [pandas time delta](https://pandas.pydata.org/pandas-docs/stable/user_guide/timedeltas.html#parsing){:target=&#34;_blank&#34;}

    Raises
    ------
    TypeError
        * Raised when the `function` is not an instance of Callable or FuncWrapper.
        * Raised when `window` and `stride` are not of exactly the same type (when
          `stride` is not None).

    See Also
    --------
    StridedRolling: As the window-stride sequence conversion takes place there.

    &#34;&#34;&#34;

    def __init__(
        self,
        function: Union[FuncWrapper, Callable],
        series_name: Union[str, Tuple[str, ...]],
        window: Optional[Union[float, str, pd.Timedelta]] = None,
        stride: Optional[
            Union[float, str, pd.Timedelta, List[Union[float, str, pd.Timedelta]]]
        ] = None,
    ):
        strides = sorted(set(to_list(stride)))  # omit duplicate stride values
        if window is None:
            assert strides == [None], &#34;stride must be None if window is None&#34;
        self.series_name: Tuple[str, ...] = to_tuple(series_name)
        self.window = parse_time_arg(window) if isinstance(window, str) else window
        if strides == [None]:
            self.stride = None
        else:
            self.stride = [
                parse_time_arg(s) if isinstance(s, str) else s for s in strides
            ]

        # Verify whether window and stride are either both sequence or time based
        dtype_set = set(
            AttributeParser.determine_type(v)
            for v in [self.window] + to_list(self.stride)
        ).difference([DataType.UNDEFINED])
        if len(dtype_set) &gt; 1:
            raise TypeError(
                f&#34;a combination of window ({self.window} type={type(self.window)}) and&#34;
                f&#34; stride ({self.stride}) is not supported!&#34;
            )

        # Order of if statements is important (as FuncWrapper also is a Callable)!
        if isinstance(function, FuncWrapper):
            self.function: FuncWrapper = function
        elif isinstance(function, Callable):
            self.function: FuncWrapper = FuncWrapper(function)
        else:
            raise TypeError(
                &#34;Expected feature function to be a `FuncWrapper` but is a&#34;
                f&#34; {type(function)}.&#34;
            )

        # Construct a function-string
        f_name = str(self.function)
        self._func_str: str = f&#34;{self.__class__.__name__} - func: {f_name}&#34;

        self._freeze()

    def get_required_series(self) -&gt; List[str]:
        &#34;&#34;&#34;Return all required series names for this feature descriptor.

        Return the list of series names that are required in order to execute the
        feature function.

        Returns
        -------
        List[str]
            List of all the required series names.

        &#34;&#34;&#34;
        return list(set(self.series_name))

    def get_nb_output_features(self) -&gt; int:
        &#34;&#34;&#34;Return the number of output features of this feature descriptor.

        Returns
        -------
        int
            Number of output features.

        &#34;&#34;&#34;
        return len(self.function.output_names)

    def __repr__(self) -&gt; str:
        &#34;&#34;&#34;Representation string of Feature.&#34;&#34;&#34;
        return (
            f&#34;{self.__class__.__name__}({self.series_name}, {self.window}, &#34;
            f&#34;{self.stride})&#34;
        )</code></pre>
</details>
<div class="desc"><p>A FeatureDescriptor object, containing all feature information.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>function</code></strong> :&ensp;<code>Union[<a title="tsflex.features.FuncWrapper" href="#tsflex.features.FuncWrapper">FuncWrapper</a>, Callable]</code></dt>
<dd>
<p>The function that calculates the feature(s).
The prototype of the function should match: </p>
<pre><code>function(*series: Union[np.array, pd.Series])
    -&gt; Union[Any, List[Any]]
</code></pre>
<p>Note that when the input type is <code>pd.Series</code>, the function should be wrapped
in a <code><a title="tsflex.features.FuncWrapper" href="#tsflex.features.FuncWrapper">FuncWrapper</a></code> with <code>input_type</code> = <code>pd.Series</code>.</p>
</dd>
<dt><strong><code>series_name</code></strong> :&ensp;<code>Union[str, Tuple[str, &hellip;]]</code></dt>
<dd>
<p>The names of the series on which the feature function should be applied.
This argument should match the <code>function</code> its input; </p>
<ul>
<li>If <code>series_name</code> is a string (or tuple of a single string), then
<code>function</code> should require just one series as input.</li>
<li>If <code>series_name</code> is a tuple of strings, then <code>function</code> should
require <code>len(tuple)</code> series as input <strong>and in exactly the same order</strong></li>
</ul>
</dd>
<dt><strong><code>window</code></strong> :&ensp;<code>Union[float, str, pd.Timedelta]</code>, optional</dt>
<dd>
<p>The window size. By default None. This argument supports multiple types: </p>
<ul>
<li>If None, the <code>segment_start_idxs</code> and <code>segment_end_idxs</code> will need to be
passed.</li>
<li>If the type is an <code>float</code> or an <code>int</code>, its value represents the series<ul>
<li>its window <strong>range</strong> when a <strong>non time-indexed</strong> series is passed.</li>
<li>its window in <strong>number of samples</strong>, when a <strong>time-indexed</strong> series is
passed (must then be and <code>int</code>)</li>
</ul>
</li>
<li>If the window's type is a <code>pd.Timedelta</code>, the window size represents
the window-time-range. The passed data <strong>must have a time-index</strong>.</li>
<li>If a <code>str</code>, it must represents a window-time-range-string. The <strong>passed data
must have a time-index</strong>.</li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ul>
<li>When the <code>segment_start_idxs</code> and <code>segment_end_idxs</code> are both passed to
the <code><a title="tsflex.features.FeatureCollection.calculate" href="#tsflex.features.FeatureCollection.calculate">.calculate()</a></code> method, this window argument is ignored.
Note that this is the only case when it is allowed to pass None for the
window argument.</li>
<li>When the window argument is None, than the stride argument should be None
as well (as it makes no sense to pass a stride value when the window is
None).</li>
</ul>
</div>
</dd>
<dt><strong><code>stride</code></strong> :&ensp;<code>Union[float, str, pd.Timedelta, List[Union[float, str, pd.Timedelta]]]</code>, optional</dt>
<dd>
<p>The stride size(s). By default None. This argument supports multiple types: </p>
<ul>
<li>If None, the stride will need to be passed to <code><a title="tsflex.features.FeatureCollection.calculate" href="#tsflex.features.FeatureCollection.calculate">.calculate()</a></code>.</li>
<li>If the type is an <code>float</code> or an <code>int</code>, its value represents the series<ul>
<li>its stride <strong>range</strong> when a <strong>non time-indexed</strong> series is passed.</li>
<li>the stride in <strong>number of samples</strong>, when a <strong>time-indexed</strong> series
is passed (must then be and <code>int</code>)</li>
</ul>
</li>
<li>If the stride's type is a <code>pd.Timedelta</code>, the stride size represents
the stride-time delta. The passed data <strong>must have a time-index</strong>.</li>
<li>
<p>If a <code>str</code>, it must represent a stride-time-delta-string. The <strong>passed data
must have a time-index</strong>. </p>
</li>
<li>
<p>If a <code>List[Union[float, str, pd.Timedelta]]</code>, then the set intersection,of the
strides will be used (e.g., stride=[2,3] -&gt; index: 0, 2, 3, 4, 6, 8, 9, &hellip;)</p>
</li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ul>
<li>The stride argument of <code><a title="tsflex.features.FeatureCollection.calculate" href="#tsflex.features.FeatureCollection.calculate">.calculate()</a></code> takes precedence over
this value when set (i.e., not None value for <code>stride</code> passed to the
<code>calculate</code> method).</li>
<li>The stride argument should be None when the window argument is None (as it
makes no sense to pass a stride value when the window is None).</li>
</ul>
</div>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>As described above, the <code>window-stride</code> argument can be sample-based (when using
time-index series and int based arguments), but we
do <strong>not encourage</strong> using this for <code>time-indexed</code> sequences. As we make the
implicit assumption that the time-based data is sampled at a fixed frequency
So only, if you're 100% sure that this is correct, you can safely use such
arguments.</p>
</div>
<h2 id="notes">Notes</h2>
<ul>
<li>The <code>window</code> and <code>stride</code> argument should be either <strong>both</strong> numeric or
<code>pd.Timedelta</code> (depending on de index datatype) - when <code>stride</code> is not None.</li>
<li>For each <code>function</code> - <code>input</code>(-series) - <code>window</code> - stride combination, one needs
to create a distinct <code><a title="tsflex.features.FeatureDescriptor" href="#tsflex.features.FeatureDescriptor">FeatureDescriptor</a></code>. Hence it is more convenient to
create a <code><a title="tsflex.features.MultipleFeatureDescriptors" href="#tsflex.features.MultipleFeatureDescriptors">MultipleFeatureDescriptors</a></code> when <code>function</code> - <code>window</code> - <code>stride</code>
<strong>combinations</strong> should be applied on various input-series (combinations).</li>
<li>When <code>function</code> takes <strong>multiple series</strong> (i.e., arguments) as <strong>input</strong>, these
are joined (based on the index) before applying the function. If the indexes of
these series are not exactly the same, it might occur that not all series have
exactly the same length! Hence,
make sure that the <code>function</code> can deal with
this!</li>
<li>For more information about the str-based time args, look into:
<a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/timedeltas.html#parsing" target="_blank">pandas time delta</a></li>
</ul>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>
<ul>
<li>Raised when the <code>function</code> is not an instance of Callable or FuncWrapper.</li>
<li>Raised when <code>window</code> and <code>stride</code> are not of exactly the same type (when
<code>stride</code> is not None).</li>
</ul>
</dd>
</dl>
<h2 id="see-also">See Also</h2>
<dl>
<dt><code>StridedRolling</code></dt>
<dd>As the window-stride sequence conversion takes place there.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>tsflex.utils.classes.FrozenClass</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="tsflex.features.FeatureDescriptor.get_required_series"><code class="name flex">
<span>def <span class="ident">get_required_series</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_required_series(self) -&gt; List[str]:
    &#34;&#34;&#34;Return all required series names for this feature descriptor.

    Return the list of series names that are required in order to execute the
    feature function.

    Returns
    -------
    List[str]
        List of all the required series names.

    &#34;&#34;&#34;
    return list(set(self.series_name))</code></pre>
</details>
<div class="desc"><p>Return all required series names for this feature descriptor.</p>
<p>Return the list of series names that are required in order to execute the
feature function.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List[str]</code></dt>
<dd>List of all the required series names.</dd>
</dl></div>
</dd>
<dt id="tsflex.features.FeatureDescriptor.get_nb_output_features"><code class="name flex">
<span>def <span class="ident">get_nb_output_features</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_nb_output_features(self) -&gt; int:
    &#34;&#34;&#34;Return the number of output features of this feature descriptor.

    Returns
    -------
    int
        Number of output features.

    &#34;&#34;&#34;
    return len(self.function.output_names)</code></pre>
</details>
<div class="desc"><p>Return the number of output features of this feature descriptor.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>Number of output features.</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="tsflex.features.MultipleFeatureDescriptors"><code class="flex name class">
<span>class <span class="ident">MultipleFeatureDescriptors</span></span>
<span>(</span><span>functions, series_names, windows=None, strides=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MultipleFeatureDescriptors:
    &#34;&#34;&#34;Create a MultipleFeatureDescriptors object.

    Create a list of features from **all** combinations of the given parameter
    lists. Total number of created `FeatureDescriptor`s will be:

        len(func_inputs)*len(functions)*len(windows)*len(strides).

    Parameters
    ----------
    functions : Union[FuncWrapper, Callable, List[Union[FuncWrapper, Callable]]]
        The functions, can be either of both types (even in a single array).
    series_names : Union[str, Tuple[str, ...], List[str], List[Tuple[str, ...]]]
        The names of the series on which the feature function should be applied.

        * If `series_names` is a (list of) string (or tuple of a single string),
          then each `function` should require just one series as input.
        * If `series_names` is a (list of) tuple of strings, then each `function` should
          require `len(tuple)` series as input.

        A `list` implies that multiple multiple series (combinations) will be used to
        extract features from; \n
        * If `series_names` is a string or a tuple of strings, then `function` will
          be called only once for the series of this argument.
        * If `series_names` is a list of either strings or tuple of strings, then
          `function` will be called for each entry of this list.

        .. Note::
            when passing a list as `series_names`, all items in this list should
            have the same type, i.e, either \n
            * all a str
            * or, all a tuple _with same length_.\n
            And perfectly match the func-input size.

    windows : Union[float, str, pd.Timedelta, List[Union[float, str, pd.Timedelta]]]
        All the window sizes.
    strides : Union[float, str, pd.Timedelta, None, List[Union[float, str, pd.Timedelta]]], optional
        All the strides. By default None.

    Note
    ----
    The `windows` and `strides` argument should be either both numeric or
    ``pd.Timedelta`` (depending on de index datatype) - when `strides` is not None.

    &#34;&#34;&#34;

    def __init__(
        self,
        functions: Union[FuncWrapper, Callable, List[Union[FuncWrapper, Callable]]],
        series_names: Union[str, Tuple[str, ...], List[str], List[Tuple[str, ...]]],
        windows: Optional[
            Union[float, str, pd.Timedelta, List[Union[float, str, pd.Timedelta]]]
        ] = None,
        strides: Optional[
            Union[float, str, pd.Timedelta, List[Union[float, str, pd.Timedelta]]]
        ] = None,
    ):
        # Cast functions to FuncWrapper, this avoids creating multiple
        # FuncWrapper objects for the same function in the FeatureDescriptor
        def to_func_wrapper(f: Callable):
            return f if isinstance(f, FuncWrapper) else FuncWrapper(f)

        functions = [to_func_wrapper(f) for f in to_list(functions)]
        # Convert the series names to list of tuples
        series_names = [to_tuple(names) for names in to_list(series_names)]
        # Assert that function inputs (series) all have the same length
        assert all(
            len(series_names[0]) == len(series_name_tuple)
            for series_name_tuple in series_names
        )
        # Convert the other types to list
        windows = to_list(windows)

        self.feature_descriptions: List[FeatureDescriptor] = []
        # Iterate over all combinations
        combinations = [functions, series_names, windows]
        for function, series_name, window in itertools.product(*combinations):
            self.feature_descriptions.append(
                FeatureDescriptor(function, series_name, window, strides)
            )</code></pre>
</details>
<div class="desc"><p>Create a MultipleFeatureDescriptors object.</p>
<p>Create a list of features from <strong>all</strong> combinations of the given parameter
lists. Total number of created <code><a title="tsflex.features.FeatureDescriptor" href="#tsflex.features.FeatureDescriptor">FeatureDescriptor</a></code>s will be:</p>
<pre><code>len(func_inputs)*len(functions)*len(windows)*len(strides).
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>functions</code></strong> :&ensp;<code>Union[<a title="tsflex.features.FuncWrapper" href="#tsflex.features.FuncWrapper">FuncWrapper</a>, Callable, List[Union[<a title="tsflex.features.FuncWrapper" href="#tsflex.features.FuncWrapper">FuncWrapper</a>, Callable]]]</code></dt>
<dd>The functions, can be either of both types (even in a single array).</dd>
<dt><strong><code>series_names</code></strong> :&ensp;<code>Union[str, Tuple[str, &hellip;], List[str], List[Tuple[str, &hellip;]]]</code></dt>
<dd>
<p>The names of the series on which the feature function should be applied.</p>
<ul>
<li>If <code>series_names</code> is a (list of) string (or tuple of a single string),
then each <code>function</code> should require just one series as input.</li>
<li>If <code>series_names</code> is a (list of) tuple of strings, then each <code>function</code> should
require <code>len(tuple)</code> series as input.</li>
</ul>
<p>A <code>list</code> implies that multiple multiple series (combinations) will be used to
extract features from; </p>
<ul>
<li>If <code>series_names</code> is a string or a tuple of strings, then <code>function</code> will
be called only once for the series of this argument.</li>
<li>If <code>series_names</code> is a list of either strings or tuple of strings, then
<code>function</code> will be called for each entry of this list.</li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>when passing a list as <code>series_names</code>, all items in this list should
have the same type, i.e, either </p>
<ul>
<li>all a str</li>
<li>or, all a tuple <em>with same length</em>.</li>
</ul>
<p>And perfectly match the func-input size.</p>
</div>
</dd>
<dt><strong><code>windows</code></strong> :&ensp;<code>Union[float, str, pd.Timedelta, List[Union[float, str, pd.Timedelta]]]</code></dt>
<dd>All the window sizes.</dd>
<dt><strong><code>strides</code></strong> :&ensp;<code>Union[float, str, pd.Timedelta, None, List[Union[float, str, pd.Timedelta]]]</code>, optional</dt>
<dd>All the strides. By default None.</dd>
</dl>
<h2 id="note">Note</h2>
<p>The <code>windows</code> and <code>strides</code> argument should be either both numeric or
<code>pd.Timedelta</code> (depending on de index datatype) - when <code>strides</code> is not None.</p></div>
</dd>
<dt id="tsflex.features.FeatureCollection"><code class="flex name class">
<span>class <span class="ident">FeatureCollection</span></span>
<span>(</span><span>feature_descriptors=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FeatureCollection:
    &#34;&#34;&#34;Create a FeatureCollection.

    Parameters
    ----------
    feature_descriptors : Union[FeatureDescriptor, MultipleFeatureDescriptors, FeatureCollection, List[Union[FeatureDescriptor, MultipleFeatureDescriptors, FeatureCollection]]], optional
        Initial (list of) feature(s) to add to collection, by default None

    Notes
    -----
    * The `series_name` property of the `FeatureDescriptor`s should **not withhold a &#34;|&#34;
      character**, since &#34;|&#34; is used to join the series names of features which use
      multiple series as input).&lt;br&gt;
      e.g.&lt;br&gt;
        * `ACC|x` is **not** allowed as series name, as this is ambiguous and could
          represent that this feature is constructed with a combination of the `ACC`
          and `x` signal.&lt;br&gt;
          Note that `max|feat` is allowed as feature output name.
    * Both the `series_name` and `output_name` property of the `FeatureDescriptor`s
      **should not withhold &#34;__&#34;** in its string representations. This constraint is
      mainly made for readability purposes.

    The two statements above will be asserted

    &#34;&#34;&#34;

    def __init__(
        self,
        feature_descriptors: Optional[
            Union[
                FeatureDescriptor,
                MultipleFeatureDescriptors,
                FeatureCollection,
                List[
                    Union[
                        FeatureDescriptor, MultipleFeatureDescriptors, FeatureCollection
                    ]
                ],
            ]
        ] = None,
    ):
        # The feature collection is a dict with keys of type:
        #   tuple(tuple(str), float OR pd.timedelta)
        # The outer tuple&#39;s values correspond to (series_key(s), window)
        self._feature_desc_dict: Dict[
            Tuple[Tuple[str, ...], Union[float, pd.Timedelta]], List[FeatureDescriptor]
        ] = {}

        if feature_descriptors:
            self.add(feature_descriptors)

    def get_required_series(self) -&gt; List[str]:
        &#34;&#34;&#34;Return all required series names for this feature collection.

        Return the list of series names that are required in order to calculate all the
        features (defined by the `FeatureDescriptor` objects) of this feature
        collection.

        Returns
        -------
        List[str]
            List of all the required series names.

        &#34;&#34;&#34;
        return list(
            set(flatten([fr_key[0] for fr_key in self._feature_desc_dict.keys()]))
        )

    def get_nb_output_features(self) -&gt; int:
        &#34;&#34;&#34;Return the number of output features in this feature collection.

        Returns
        -------
        int
            The number of output features in this feature collection.

        &#34;&#34;&#34;
        fd_list: Iterable[FeatureDescriptor] = flatten(self._feature_desc_dict.values())
        return sum(fd.get_nb_output_features() for fd in fd_list)

    def _get_nb_output_features_without_window(self) -&gt; int:
        &#34;&#34;&#34;Return the number of output features in this feature collection, without
        using the window as a unique identifier.

        This is relevant for when the window value(s) are overridden by passing
        `segment_start_idxs` and `segment_end_idxs` to the `calculate` method.

        Returns
        -------
        int:
            The number of output features in this feature collection without using the
            window as a unique identifier.

        &#34;&#34;&#34;
        return len(
            set(
                (series, o)
                for (series, _), fd_list in self._feature_desc_dict.items()
                for fd in fd_list
                for o in fd.function.output_names
            )
        )

    @staticmethod
    def _get_collection_key(
        feature: FeatureDescriptor,
    ) -&gt; Tuple[Tuple[str, ...], Union[pd.Timedelta, float, None]]:
        # Note: `window` property can be either a pd.Timedelta or a float or None
        # assert feature.window is not None
        return feature.series_name, feature.window

    def _check_feature_descriptors(
        self,
        skip_none: bool,
        calc_stride: Optional[Union[float, pd.Timedelta, None]] = None,
    ):
        &#34;&#34;&#34;Verify whether all added FeatureDescriptors imply the same-input data type.

        If this condition is not met, a warning will be raised.

        Parameters
        ----------
        skip_none: bool
            Whether to include None stride values in the checks.
        calc_stride: Union[float, pd.Timedelta, None], optional
            The `FeatureCollection.calculate` its stride argument, by default None.
            This stride takes precedence over a `FeatureDescriptor` its stride when
            it is not None.

        &#34;&#34;&#34;
        dtype_set = set()
        for series_names, win in self._feature_desc_dict.keys():
            for fd in self._feature_desc_dict[(series_names, win)]:
                stride = calc_stride if calc_stride is not None else fd.stride
                if skip_none and stride is None:
                    dtype_set.add(AttributeParser.determine_type(win))
                else:
                    dtype_set.add(
                        AttributeParser.determine_type([win] + to_list(stride))
                    )

        if len(dtype_set) &gt; 1:
            warnings.warn(
                &#34;There are multiple FeatureDescriptor window-stride &#34;
                + f&#34;datatypes present in this FeatureCollection, i.e.: {dtype_set}&#34;,
                category=RuntimeWarning,
            )

    def _add_feature(self, feature: FeatureDescriptor):
        &#34;&#34;&#34;Add a `FeatureDescriptor` instance to the collection.

        Parameters
        ----------
        feature : FeatureDescriptor
            The feature that will be added to this feature collection.

        &#34;&#34;&#34;
        # Check whether the `|` is not present in the series
        assert not any(&#34;|&#34; in s_name for s_name in feature.get_required_series())
        # Check whether the &#39;__&#34; is not present in the series and function output names
        assert not any(
            &#34;__&#34; in output_name for output_name in feature.function.output_names
        )
        assert not any(&#34;__&#34; in s_name for s_name in feature.get_required_series())

        series_win_stride_key = self._get_collection_key(feature)
        if series_win_stride_key in self._feature_desc_dict.keys():
            added_output_names = flatten(
                f.function.output_names
                for f in self._feature_desc_dict[series_win_stride_key]
            )
            # Check that not a feature with the same output_name(s) is already added
            # for the series_win_stride_key
            assert not any(
                output_name in added_output_names
                for output_name in feature.function.output_names
            )
            self._feature_desc_dict[series_win_stride_key].append(feature)
        else:
            self._feature_desc_dict[series_win_stride_key] = [feature]

    def add(
        self,
        features: Union[
            FeatureDescriptor,
            MultipleFeatureDescriptors,
            FeatureCollection,
            List[
                Union[FeatureDescriptor, MultipleFeatureDescriptors, FeatureCollection]
            ],
        ],
    ):
        &#34;&#34;&#34;Add feature(s) to the FeatureCollection.

        Parameters
        ----------
        features : Union[FeatureDescriptor, MultipleFeatureDescriptors, FeatureCollection, List[Union[FeatureDescriptor, MultipleFeatureDescriptors, FeatureCollection]]]
            Feature(s) (containers) whose contained features will be added.

        Raises
        ------
        TypeError
            Raised when an item within `features` is not an instance of
            [`MultipleFeatureDescriptors`, `FeatureDescriptors`, `FeatureCollection`].

        &#34;&#34;&#34;
        # Convert to list if necessary
        features = to_list(features)

        for feature in features:
            if isinstance(feature, MultipleFeatureDescriptors):
                self.add(feature.feature_descriptions)
            elif isinstance(feature, FeatureDescriptor):
                self._add_feature(feature)
            elif isinstance(feature, FeatureCollection):
                # List needs to be flattened
                self.add(list(flatten(feature._feature_desc_dict.values())))
            else:
                raise TypeError(f&#34;type: {type(feature)} is not supported - {feature}&#34;)

        # After adding the features, check whether the descriptors are compatible
        self._check_feature_descriptors(skip_none=True)

    @staticmethod
    def _executor(idx: int):
        # global get_stroll_func
        stroll, function = get_stroll_func(idx)
        return stroll.apply_func(function)

    # def _get_stroll(self, kwargs):
    #     return StridedRollingFactory.get_segmenter(**kwargs)

    def _stroll_feat_generator(
        self,
        series_dict: Dict[str, pd.Series],
        calc_stride: Union[List[Union[float, pd.Timedelta]], None],
        segment_start_idxs: Union[np.ndarray, None],
        segment_end_idxs: Union[np.ndarray, None],
        start_idx: Any,
        end_idx: Any,
        window_idx: str,
        include_final_window: bool,
        approve_sparsity: bool,
    ) -&gt; Callable[[int], Tuple[StridedRolling, FuncWrapper]]:
        # --- Future work ---
        # We could also make the StridedRolling creation multithreaded
        # Very low priority because the STROLL __init__ is rather efficient!
        keys_wins_strides = list(self._feature_desc_dict.keys())
        lengths = np.cumsum(
            [len(self._feature_desc_dict[k]) for k in keys_wins_strides]
        )

        def get_stroll_function(idx) -&gt; Tuple[StridedRolling, FuncWrapper]:
            key_idx = np.searchsorted(lengths, idx, &#34;right&#34;)  # right bc idx starts at 0
            key, win = keys_wins_strides[key_idx]

            feature = self._feature_desc_dict[keys_wins_strides[key_idx]][
                idx - lengths[key_idx]
            ]
            stride = feature.stride if calc_stride is None else calc_stride
            function: FuncWrapper = feature.function
            # The factory method will instantiate the right StridedRolling object
            stroll_arg_dict = dict(
                data=[series_dict[k] for k in key],
                window=win,
                strides=stride,
                segment_start_idxs=segment_start_idxs,
                segment_end_idxs=segment_end_idxs,
                start_idx=start_idx,
                end_idx=end_idx,
                window_idx=window_idx,
                include_final_window=include_final_window,
                approve_sparsity=approve_sparsity,
                func_data_type=function.input_type,
            )
            stroll = StridedRollingFactory.get_segmenter(**stroll_arg_dict)
            return stroll, function

        return get_stroll_function

    def _get_stroll_feat_length(self) -&gt; int:
        return sum(
            len(self._feature_desc_dict[k]) for k in self._feature_desc_dict.keys()
        )

    def _check_no_multiple_windows(self):
        assert (
            self._get_nb_output_features_without_window()
            == self.get_nb_output_features()
        ), (
            &#34;When using `segment_XXX_idxs`; each output name - series_input combination&#34;
            + &#34; can only have 1 window (or None)&#34;
        )

    @staticmethod
    def _process_segment_idxs(
        segment_idxs: Union[list, np.ndarray, pd.Series, pd.Index]
    ) -&gt; np.ndarray:
        if hasattr(segment_idxs, &#34;values&#34;):
            segment_idxs = segment_idxs.values
        segment_idxs = np.asarray(segment_idxs)
        if segment_idxs.ndim &gt; 1:
            segment_idxs = segment_idxs.squeeze()  # remove singleton dimensions
        return segment_idxs

    def calculate(
        self,
        data: Union[pd.Series, pd.DataFrame, List[Union[pd.Series, pd.DataFrame]]],
        stride: Optional[Union[float, str, pd.Timedelta, List, None]] = None,
        segment_start_idxs: Optional[
            Union[list, np.ndarray, pd.Series, pd.Index]
        ] = None,
        segment_end_idxs: Optional[Union[list, np.ndarray, pd.Series, pd.Index]] = None,
        return_df: Optional[bool] = False,
        window_idx: Optional[str] = &#34;end&#34;,
        include_final_window: Optional[bool] = False,
        bound_method: Optional[str] = &#34;inner&#34;,
        approve_sparsity: Optional[bool] = False,
        show_progress: Optional[bool] = False,
        logging_file_path: Optional[Union[str, Path]] = None,
        n_jobs: Optional[int] = None,
    ) -&gt; Union[List[pd.DataFrame], pd.DataFrame]:
        &#34;&#34;&#34;Calculate features on the passed data.

        Parameters
        ----------
        data : Union[pd.Series, pd.DataFrame, List[Union[pd.Series, pd.DataFrame]]]
            Dataframe or Series or list thereof, with all the required data for the
            feature calculation. \n
            **Assumptions**: \n
            * each Series / DataFrame must have a sortable index. This index represents
            the sequence position of the corresponding values, the index can be either
            numeric or a ``pd.DatetimeIndex``.
            * each Series / DataFrame index must be comparable with all others
            * we assume that each series-name / dataframe-column-name is unique.
        stride: Union[float, str, pd.Timedelta, List[Union[float, str, pd.Timedelta], None], optional
            The stride size. By default None. This argument supports multiple types: \n
            * If None, the stride of the `FeatureDescriptor` objects will be used.
            * If the type is an `float` or an `int`, its value represents the series:\n
                - its stride **range** when a **non time-indexed** series is passed.
                - the stride in **number of samples**, when a **time-indexed** series
                is passed (must then be and `int`)
            * If the stride&#39;s type is a `pd.Timedelta`, the stride size represents
            the stride-time delta. The passed data **must have a time-index**.
            * If a `str`, it must represent a stride-time-delta-string. Hence, the
            **passed data must have a time-index**. \n
            .. Note::
                When set, this stride argument takes precedence over the stride property
                of the `FeatureDescriptor`s in this `FeatureCollection` (i.e., when a
                not None value for `stride` passed to this method).
        segment_start_idxs: Union[list, np.ndarray, pd.Series, pd.Index], optional
            The start indices of the segments. If None, the start indices will be
            computed from the data using either:\n
            - the `segment_end_idxs` - the `window` size property of the
                `FeatureDescriptor` in this `FeatureCollection` (if `segment_end_idxs`
                is not None)
            - strided-window rolling on the data using `window` and `stride` of the
                `FeatureDescriptor` in this `FeatureCollection` (if `segment_end_idxs`
                 is also None). (Note that the `stride` argument of this method takes
                 precedence over the `stride` property of the `FeatureDescriptor`s).
            By default None.
        segment_end_idxs: Union[list, np.ndarray, pd.Series, pd.Index], optional
            The end indices for the segmented windows. If None, the end indices will be
            computed from the data using either:\n
            - the `segment_start_idxs` + the `window` size property of the
                `FeatureDescriptor` in this `FeatureCollection` (if `segment_start_idxs`
                is not None)
            - strided-window rolling on the data using `window` and `stride` of the
                `FeatureDescriptor` in this `FeatureCollection` (if `segment_start_idxs`
                 is also None). (Note that the `stride` argument of this method takes
                 precedence over the `stride` property of the `FeatureDescriptor`s).
            By default None.

            ..Note::
                When passing both `segment_start_idxs` and `segment_end_idxs`, these two
                arguments must have the same length and every start index must be &lt;=
                than the corresponding end index.
                Note that passing both arguments, discards any meaning of the `window`
                and `stride` values (as these segment indices define the segmented data,
                and thus no strided-window rolling index calculation has to be executed).
                As such, the user can create variable-length segmented windows. However,
                in such cases, the user should be weary that the feature functions are
                invariant to these (potentially variable-length) windows.
        return_df : bool, optional
            Whether the output needs to be a DataFrame or a list thereof, by default
            False. If `True` the output dataframes will be merged to a DataFrame with an
            outer merge.
        window_idx : str, optional
            The window&#39;s index position which will be used as index for the
            feature_window aggregation. Must be either of: `[&#34;begin&#34;, &#34;middle&#34;, &#34;end&#34;]`.
            by **default &#34;end&#34;**. All features in this collection will use the same
            window_idx.

            ..Note::
                `window_idx`=&#34;end&#34; uses the window&#39;s end (= right open bound) as
                output index. \n
                `window_idx`=&#34;begin&#34; uses the window&#39;s start idx (= left closed bound)
                as output index.
        include_final_window : bool, optional
            Whether the final (possibly incomplete) window should be included in the
            strided-window segmentation, by default False.

            .. Note::
                The remarks below apply when `include_final_window` is set to True.
                The user should be aware that the last window *might* be incomplete,
                i.e.;

                - when equally sampled, the last window *might* be smaller than the
                  the other windows.
                - when not equally sampled, the last window *might* not include all the
                  data points (as the begin-time + window-size comes after the last data
                  point).

                Note, that when equally sampled, the last window *will* be a full window
                when:

                - the stride is the sampling rate of the data (or stride = 1 for
                sample-based configurations).&lt;br&gt;
                **Remark**: that when `include_final_window` is set to False, the last
                window (which is a full) window will not be included!
                - *(len * sampling_rate - window_size) % stride = 0*. Remark that the
                  above case is a base case of this.
        bound_method: str, optional
            The start-end bound methodology which is used to generate the slice ranges
            when ``data`` consists of multiple series / columns.
            Must be either of: `[&#34;inner&#34;, &#34;inner-outer&#34;, &#34;outer&#34;]`, by default &#34;inner&#34;.

            * if ``inner``, the inner-bounds of the series are returned.
            * if ``inner-outer``, the left-inner and right-outer bounds of the series
              are returned.
            * if ``outer``, the outer-bounds of the series are returned.
        approve_sparsity: bool, optional
            Bool indicating whether the user acknowledges that there may be sparsity
            (i.e., irregularly sampled data), by default False.
            If False and sparsity is observed, a warning is raised.
        show_progress: bool, optional
            If True, the progress will be shown with a progressbar, by default False.
        logging_file_path : Union[str, Path], optional
            The file path where the logged messages are stored. If `None`, then no
            logging `FileHandler` will be used and the logging messages are only pushed
            to stdout. Otherwise, a logging `FileHandler` will write the logged messages
            to the given file path. See also the `tsflex.features.logger` module.
        n_jobs : int, optional
            The number of processes used for the feature calculation. If `None`, then
            the number returned by _os.cpu_count()_ is used, by default None. \n
            If n_jobs is either 0 or 1, the code will be executed sequentially without
            creating a process pool. This is very useful when debugging, as the stack
            trace will be more comprehensible.
            .. note::
                Multiprocessed execution is not supported on Windows. Even when,
                `n_jobs` is set &gt; 1, the feature extraction will still be executed
                sequentially.
                Why do we not support multiprocessing on Windows; see this issue
                https://github.com/predict-idlab/tsflex/issues/51

            .. tip::
                It takes on avg. _300ms_ to schedule everything with
                multiprocessing. So if your sequential feature extraction code runs
                faster than ~1s, it might not be worth it to parallelize the process
                (and thus better leave `n_jobs` to 0 or 1).

        Returns
        -------
        Union[List[pd.DataFrame], pd.DataFrame]
            The calculated features.

        Raises
        ------
        KeyError
            Raised when a required key is not found in `data`.

        Notes
        ------
        * The (column-)names of the series in `data` represent the `series_names`.
        * If a `logging_file_path` is provided, the execution (time) info can be
          retrieved by calling `logger.get_feature_logs(logging_file_path)`.
          Be aware that the `logging_file_path` gets cleared before the logger pushes
          logged messages. Hence, one should use a separate logging file for each
          constructed processing and feature instance with this library.


        &#34;&#34;&#34;
        # Delete other logging handlers
        delete_logging_handlers(logger)
        # Add logging handler (if path provided)
        if logging_file_path:
            f_handler = add_logging_handler(logger, logging_file_path)

        # Convert to numpy array (if necessary)
        if segment_start_idxs is not None:
            segment_start_idxs = FeatureCollection._process_segment_idxs(
                segment_start_idxs
            )
        if segment_end_idxs is not None:
            segment_end_idxs = FeatureCollection._process_segment_idxs(segment_end_idxs)

        if segment_start_idxs is not None and segment_end_idxs is not None:
            # Check if segment indices have same length and whether every start idx
            # &lt;= end idx
            _check_start_end_array(segment_start_idxs, segment_end_idxs)
            # Check if there is either 1 or No(ne) window value for every output name -
            # input_series combination
            self._check_no_multiple_windows()

        if segment_start_idxs is None or segment_end_idxs is None:
            assert all(
                fd.window is not None
                for fd in flatten(self._feature_desc_dict.values())
            ), (
                &#34;Each feature descriptor must have a window when not both &#34;
                + &#34;segment_start_idxs and segment_end_idxs are provided&#34;
            )

        if stride is None and segment_start_idxs is None and segment_end_idxs is None:
            assert all(
                fd.stride is not None
                for fd in flatten(self._feature_desc_dict.values())
            ), (
                &#34;Each feature descriptor must have a stride when no stride or &#34;
                + &#34;segment indices are passed to this method!&#34;
            )
        elif stride is not None and (
            segment_start_idxs is not None or segment_end_idxs is not None
        ):
            raise ValueError(
                &#34;The stride and any segment index argument cannot be set together! &#34;
                + &#34;At least one of both should be None.&#34;
            )

        if stride is not None:
            # Verify whether the stride complies with the input data dtype
            stride = [
                parse_time_arg(s) if isinstance(s, str) else s for s in to_list(stride)
            ]
            self._check_feature_descriptors(skip_none=False, calc_stride=stride)

        # Convert the data to a series_dict
        series_dict: Dict[str, pd.Series] = {}
        for s in to_series_list(data):
            if not s.index.is_monotonic_increasing:
                warnings.warn(
                    f&#34;The index of series &#39;{s.name}&#39; is not monotonic increasing. &#34;
                    + &#34;The series will be sorted by the index.&#34;,
                    RuntimeWarning,
                )
                s = s.sort_index(ascending=True, inplace=False, ignore_index=False)

            # Assert the assumptions we make!
            assert s.index.is_monotonic_increasing

            if s.name in self.get_required_series():
                series_dict[str(s.name)] = s

        # Determine the bounds of the series dict items and slice on them
        # TODO: is dit wel nodig `hier? want we doen dat ook in de strided rolling
        start, end = _determine_bounds(bound_method, list(series_dict.values()))
        series_dict = {
            n: s.loc[
                s.index.dtype.type(start) : s.index.dtype.type(end)
            ]  # TODO: check memory efficiency of ths
            for n, s, in series_dict.items()
        }

        # Note: this variable has a global scope so this is shared in multiprocessing
        # TODO: try to make this more efficient (but is not really the bottleneck)
        global get_stroll_func
        get_stroll_func = self._stroll_feat_generator(
            series_dict,
            calc_stride=stride,
            segment_start_idxs=segment_start_idxs,
            segment_end_idxs=segment_end_idxs,
            start_idx=start,
            end_idx=end,
            window_idx=window_idx,
            include_final_window=include_final_window,
            approve_sparsity=approve_sparsity,
        )
        nb_stroll_funcs = self._get_stroll_feat_length()

        if (
            os.name == &#34;nt&#34;
        ):  # On Windows no multiprocessing is supported, see https://github.com/predict-idlab/tsflex/issues/51
            n_jobs = 1
        elif n_jobs is None:
            n_jobs = os.cpu_count()
        n_jobs = min(n_jobs, nb_stroll_funcs)

        calculated_feature_list = None
        if n_jobs in [0, 1]:
            idxs = range(nb_stroll_funcs)
            if show_progress:
                idxs = tqdm(idxs)
            try:
                calculated_feature_list = [self._executor(idx) for idx in idxs]
            except Exception:
                traceback.print_exc()
        else:
            with Pool(processes=n_jobs) as pool:
                results = pool.imap_unordered(self._executor, range(nb_stroll_funcs))
                if show_progress:
                    results = tqdm(results, total=nb_stroll_funcs)
                try:
                    calculated_feature_list = [f for f in results]
                except Exception:
                    traceback.print_exc()
                    pool.terminate()
                finally:
                    # Close &amp; join because: https://github.com/uqfoundation/pathos/issues/131
                    pool.close()
                    pool.join()

        # Close the file handler (this avoids PermissionError: [WinError 32])
        if logging_file_path:
            f_handler.close()
            logger.removeHandler(f_handler)

        if calculated_feature_list is None:
            raise RuntimeError(
                &#34;Feature Extraction halted due to error while extracting one &#34;
                + &#34;(or multiple) feature(s)! See stack trace above.&#34;
            )

        if return_df:
            # concatenate &amp; sort the columns
            df = pd.concat(calculated_feature_list, axis=1, join=&#34;outer&#34;, copy=False)
            return df.reindex(sorted(df.columns), axis=1)
        else:
            return calculated_feature_list

    def serialize(self, file_path: Union[str, Path]):
        &#34;&#34;&#34;Serialize this FeatureCollection instance.

        Parameters
        ----------
        file_path : Union[str, Path]
            The path where the `FeatureCollection` will be serialized.

        Note
        -----
        As we use [Dill](https://github.com/uqfoundation/dill){:target=&#34;_blank&#34;} to
        serialize the files, we can **also serialize functions which are defined in
        the local scope, like lambdas.**

        &#34;&#34;&#34;
        with open(file_path, &#34;wb&#34;) as f:
            dill.dump(self, f, recurse=True)

    def reduce(self, feat_cols_to_keep: List[str]) -&gt; FeatureCollection:
        &#34;&#34;&#34;Create a reduced FeatureCollection instance based on `feat_cols_to_keep`.

        For example, this is useful to optimize feature-extraction inference
        (for your selected features) after performing a feature-selection procedure.

        Parameters
        ----------
        feat_cols_to_keep: List[str]
            A subset of the feature collection instance its column names.
            This corresponds to the columns / names of the output from `calculate`
            method that you want to keep.

        Returns
        -------
        FeatureCollection
            A new FeatureCollection object, which only withholds the FeatureDescriptors
            which constitute the `feat_cols_to_keep` output.

        Note
        ----
        Some FeatureDescriptor objects may have multiple **output-names**.&lt;br&gt;
        Hence, if you only want to retain _a subset_ of that FeatureDescriptor its
        feature outputs, you will still get **all features** as the new
        FeatureCollection is constructed by applying a filter on de FeatureDescriptor
        list and we thus not alter these FeatureDescriptor objects themselves.

        &#34;&#34;&#34;
        # dict in which we store all the { output_col_name : (UUID, FeatureDescriptor) }
        # items of our current FeatureCollection object
        manual_window = False
        if any(c.endswith(&#34;w=manual&#34;) for c in feat_cols_to_keep):
            assert all(c.endswith(&#34;w=manual&#34;) for c in feat_cols_to_keep)
            # As the windows are created manual, the FeatureCollection cannot contain
            # multiple windows for the same output name - input_series combination
            self._check_no_multiple_windows()
            manual_window = True
        feat_col_fd_mapping: Dict[str, Tuple[str, FeatureDescriptor]] = {}
        for (s_names, window), fd_list in self._feature_desc_dict.items():
            window = &#34;manual&#34; if manual_window else self._ws_to_str(window)
            for fd in fd_list:
                # As a single FeatureDescriptor can have multiple output col names, we
                # create a unique identifier for each FeatureDescriptor (on which we
                # will apply set-like operations later on to only retain all the unique
                # FeatureDescriptors)
                uuid_str = str(uuid.uuid4())
                for output_name in fd.function.output_names:
                    # Reconstruct the feature column name
                    feat_col_name = StridedRolling.construct_output_index(
                        series_keys=s_names, feat_name=output_name, win_str=window
                    )
                    feat_col_fd_mapping[feat_col_name] = (uuid_str, fd)

        assert all(fc in feat_col_fd_mapping for fc in feat_cols_to_keep)

        # Collect (uuid, FeatureDescriptor) for the feat_cols_to_keep
        fd_subset: List[Tuple[str, FeatureDescriptor]] = [
            feat_col_fd_mapping[fc] for fc in feat_cols_to_keep
        ]

        # Reduce to unique feature descriptor objects (based on uuid) and create a new
        # FeatureCollection for their deepcopy&#39;s.
        seen_uuids = set()
        return FeatureCollection(
            feature_descriptors=[
                deepcopy(unique_fd)
                for unique_fd in {
                    fd
                    for (uuid_str, fd) in fd_subset
                    if uuid_str not in seen_uuids and not seen_uuids.add(uuid_str)
                }
            ]
        )

    @staticmethod
    def _ws_to_str(window_or_stride: Any) -&gt; str:
        &#34;&#34;&#34;Convert the window/stride value to a (shortend) string representation.&#34;&#34;&#34;
        if isinstance(window_or_stride, pd.Timedelta):
            return timedelta_to_str(window_or_stride)
        else:
            return str(window_or_stride)

    def __repr__(self) -&gt; str:
        &#34;&#34;&#34;Representation string of a FeatureCollection.&#34;&#34;&#34;
        feature_keys = sorted(set(k[0] for k in self._feature_desc_dict.keys()))
        output_str = &#34;&#34;
        for feature_key in feature_keys:
            output_str += f&#34;{&#39;|&#39;.join(feature_key)}: (&#34;
            keys = (x for x in self._feature_desc_dict.keys() if x[0] == feature_key)
            for _, win_size in keys:
                output_str += &#34;\n\twin: &#34;
                win_str = self._ws_to_str(win_size)
                output_str += f&#34;{win_str:&lt;6}: [&#34;
                for feat_desc in self._feature_desc_dict[feature_key, win_size]:
                    stride_str = feat_desc.stride
                    if stride_str is not None:
                        stride_str = [self._ws_to_str(s) for s in stride_str]
                    output_str += f&#34;\n\t\t{feat_desc._func_str}&#34;
                    output_str += f&#34;    stride: {stride_str},&#34;
                output_str += &#34;\n\t]&#34;
            output_str += &#34;\n)\n&#34;
        return output_str</code></pre>
</details>
<div class="desc"><p>Create a FeatureCollection.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>feature_descriptors</code></strong> :&ensp;<code>Union[<a title="tsflex.features.FeatureDescriptor" href="#tsflex.features.FeatureDescriptor">FeatureDescriptor</a>, <a title="tsflex.features.MultipleFeatureDescriptors" href="#tsflex.features.MultipleFeatureDescriptors">MultipleFeatureDescriptors</a>, <a title="tsflex.features.FeatureCollection" href="#tsflex.features.FeatureCollection">FeatureCollection</a>, List[Union[<a title="tsflex.features.FeatureDescriptor" href="#tsflex.features.FeatureDescriptor">FeatureDescriptor</a>, <a title="tsflex.features.MultipleFeatureDescriptors" href="#tsflex.features.MultipleFeatureDescriptors">MultipleFeatureDescriptors</a>, <a title="tsflex.features.FeatureCollection" href="#tsflex.features.FeatureCollection">FeatureCollection</a>]]]</code>, optional</dt>
<dd>Initial (list of) feature(s) to add to collection, by default None</dd>
</dl>
<h2 id="notes">Notes</h2>
<ul>
<li>The <code>series_name</code> property of the <code><a title="tsflex.features.FeatureDescriptor" href="#tsflex.features.FeatureDescriptor">FeatureDescriptor</a></code>s should <strong>not withhold a "|"
character</strong>, since "|" is used to join the series names of features which use
multiple series as input).<br>
e.g.<br><ul>
<li><code>ACC|x</code> is <strong>not</strong> allowed as series name, as this is ambiguous and could
represent that this feature is constructed with a combination of the <code>ACC</code>
and <code>x</code> signal.<br>
Note that <code>max|feat</code> is allowed as feature output name.</li>
</ul>
</li>
<li>Both the <code>series_name</code> and <code>output_name</code> property of the <code><a title="tsflex.features.FeatureDescriptor" href="#tsflex.features.FeatureDescriptor">FeatureDescriptor</a></code>s
<strong>should not withhold "__"</strong> in its string representations. This constraint is
mainly made for readability purposes.</li>
</ul>
<p>The two statements above will be asserted</p></div>
<h3>Methods</h3>
<dl>
<dt id="tsflex.features.FeatureCollection.get_required_series"><code class="name flex">
<span>def <span class="ident">get_required_series</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_required_series(self) -&gt; List[str]:
    &#34;&#34;&#34;Return all required series names for this feature collection.

    Return the list of series names that are required in order to calculate all the
    features (defined by the `FeatureDescriptor` objects) of this feature
    collection.

    Returns
    -------
    List[str]
        List of all the required series names.

    &#34;&#34;&#34;
    return list(
        set(flatten([fr_key[0] for fr_key in self._feature_desc_dict.keys()]))
    )</code></pre>
</details>
<div class="desc"><p>Return all required series names for this feature collection.</p>
<p>Return the list of series names that are required in order to calculate all the
features (defined by the <code><a title="tsflex.features.FeatureDescriptor" href="#tsflex.features.FeatureDescriptor">FeatureDescriptor</a></code> objects) of this feature
collection.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List[str]</code></dt>
<dd>List of all the required series names.</dd>
</dl></div>
</dd>
<dt id="tsflex.features.FeatureCollection.get_nb_output_features"><code class="name flex">
<span>def <span class="ident">get_nb_output_features</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_nb_output_features(self) -&gt; int:
    &#34;&#34;&#34;Return the number of output features in this feature collection.

    Returns
    -------
    int
        The number of output features in this feature collection.

    &#34;&#34;&#34;
    fd_list: Iterable[FeatureDescriptor] = flatten(self._feature_desc_dict.values())
    return sum(fd.get_nb_output_features() for fd in fd_list)</code></pre>
</details>
<div class="desc"><p>Return the number of output features in this feature collection.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>The number of output features in this feature collection.</dd>
</dl></div>
</dd>
<dt id="tsflex.features.FeatureCollection.add"><code class="name flex">
<span>def <span class="ident">add</span></span>(<span>self, features)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add(
    self,
    features: Union[
        FeatureDescriptor,
        MultipleFeatureDescriptors,
        FeatureCollection,
        List[
            Union[FeatureDescriptor, MultipleFeatureDescriptors, FeatureCollection]
        ],
    ],
):
    &#34;&#34;&#34;Add feature(s) to the FeatureCollection.

    Parameters
    ----------
    features : Union[FeatureDescriptor, MultipleFeatureDescriptors, FeatureCollection, List[Union[FeatureDescriptor, MultipleFeatureDescriptors, FeatureCollection]]]
        Feature(s) (containers) whose contained features will be added.

    Raises
    ------
    TypeError
        Raised when an item within `features` is not an instance of
        [`MultipleFeatureDescriptors`, `FeatureDescriptors`, `FeatureCollection`].

    &#34;&#34;&#34;
    # Convert to list if necessary
    features = to_list(features)

    for feature in features:
        if isinstance(feature, MultipleFeatureDescriptors):
            self.add(feature.feature_descriptions)
        elif isinstance(feature, FeatureDescriptor):
            self._add_feature(feature)
        elif isinstance(feature, FeatureCollection):
            # List needs to be flattened
            self.add(list(flatten(feature._feature_desc_dict.values())))
        else:
            raise TypeError(f&#34;type: {type(feature)} is not supported - {feature}&#34;)

    # After adding the features, check whether the descriptors are compatible
    self._check_feature_descriptors(skip_none=True)</code></pre>
</details>
<div class="desc"><p>Add feature(s) to the FeatureCollection.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>features</code></strong> :&ensp;<code>Union[<a title="tsflex.features.FeatureDescriptor" href="#tsflex.features.FeatureDescriptor">FeatureDescriptor</a>, <a title="tsflex.features.MultipleFeatureDescriptors" href="#tsflex.features.MultipleFeatureDescriptors">MultipleFeatureDescriptors</a>, <a title="tsflex.features.FeatureCollection" href="#tsflex.features.FeatureCollection">FeatureCollection</a>, List[Union[<a title="tsflex.features.FeatureDescriptor" href="#tsflex.features.FeatureDescriptor">FeatureDescriptor</a>, <a title="tsflex.features.MultipleFeatureDescriptors" href="#tsflex.features.MultipleFeatureDescriptors">MultipleFeatureDescriptors</a>, <a title="tsflex.features.FeatureCollection" href="#tsflex.features.FeatureCollection">FeatureCollection</a>]]]</code></dt>
<dd>Feature(s) (containers) whose contained features will be added.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>Raised when an item within <code>features</code> is not an instance of
[<code>MultipleFeatureDescriptors</code>, <code>FeatureDescriptors</code>, <code><a title="tsflex.features.FeatureCollection" href="#tsflex.features.FeatureCollection">FeatureCollection</a></code>].</dd>
</dl></div>
</dd>
<dt id="tsflex.features.FeatureCollection.calculate"><code class="name flex">
<span>def <span class="ident">calculate</span></span>(<span>self, data, stride=None, segment_start_idxs=None, segment_end_idxs=None, return_df=False, window_idx='end', include_final_window=False, bound_method='inner', approve_sparsity=False, show_progress=False, logging_file_path=None, n_jobs=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate(
    self,
    data: Union[pd.Series, pd.DataFrame, List[Union[pd.Series, pd.DataFrame]]],
    stride: Optional[Union[float, str, pd.Timedelta, List, None]] = None,
    segment_start_idxs: Optional[
        Union[list, np.ndarray, pd.Series, pd.Index]
    ] = None,
    segment_end_idxs: Optional[Union[list, np.ndarray, pd.Series, pd.Index]] = None,
    return_df: Optional[bool] = False,
    window_idx: Optional[str] = &#34;end&#34;,
    include_final_window: Optional[bool] = False,
    bound_method: Optional[str] = &#34;inner&#34;,
    approve_sparsity: Optional[bool] = False,
    show_progress: Optional[bool] = False,
    logging_file_path: Optional[Union[str, Path]] = None,
    n_jobs: Optional[int] = None,
) -&gt; Union[List[pd.DataFrame], pd.DataFrame]:
    &#34;&#34;&#34;Calculate features on the passed data.

    Parameters
    ----------
    data : Union[pd.Series, pd.DataFrame, List[Union[pd.Series, pd.DataFrame]]]
        Dataframe or Series or list thereof, with all the required data for the
        feature calculation. \n
        **Assumptions**: \n
        * each Series / DataFrame must have a sortable index. This index represents
        the sequence position of the corresponding values, the index can be either
        numeric or a ``pd.DatetimeIndex``.
        * each Series / DataFrame index must be comparable with all others
        * we assume that each series-name / dataframe-column-name is unique.
    stride: Union[float, str, pd.Timedelta, List[Union[float, str, pd.Timedelta], None], optional
        The stride size. By default None. This argument supports multiple types: \n
        * If None, the stride of the `FeatureDescriptor` objects will be used.
        * If the type is an `float` or an `int`, its value represents the series:\n
            - its stride **range** when a **non time-indexed** series is passed.
            - the stride in **number of samples**, when a **time-indexed** series
            is passed (must then be and `int`)
        * If the stride&#39;s type is a `pd.Timedelta`, the stride size represents
        the stride-time delta. The passed data **must have a time-index**.
        * If a `str`, it must represent a stride-time-delta-string. Hence, the
        **passed data must have a time-index**. \n
        .. Note::
            When set, this stride argument takes precedence over the stride property
            of the `FeatureDescriptor`s in this `FeatureCollection` (i.e., when a
            not None value for `stride` passed to this method).
    segment_start_idxs: Union[list, np.ndarray, pd.Series, pd.Index], optional
        The start indices of the segments. If None, the start indices will be
        computed from the data using either:\n
        - the `segment_end_idxs` - the `window` size property of the
            `FeatureDescriptor` in this `FeatureCollection` (if `segment_end_idxs`
            is not None)
        - strided-window rolling on the data using `window` and `stride` of the
            `FeatureDescriptor` in this `FeatureCollection` (if `segment_end_idxs`
             is also None). (Note that the `stride` argument of this method takes
             precedence over the `stride` property of the `FeatureDescriptor`s).
        By default None.
    segment_end_idxs: Union[list, np.ndarray, pd.Series, pd.Index], optional
        The end indices for the segmented windows. If None, the end indices will be
        computed from the data using either:\n
        - the `segment_start_idxs` + the `window` size property of the
            `FeatureDescriptor` in this `FeatureCollection` (if `segment_start_idxs`
            is not None)
        - strided-window rolling on the data using `window` and `stride` of the
            `FeatureDescriptor` in this `FeatureCollection` (if `segment_start_idxs`
             is also None). (Note that the `stride` argument of this method takes
             precedence over the `stride` property of the `FeatureDescriptor`s).
        By default None.

        ..Note::
            When passing both `segment_start_idxs` and `segment_end_idxs`, these two
            arguments must have the same length and every start index must be &lt;=
            than the corresponding end index.
            Note that passing both arguments, discards any meaning of the `window`
            and `stride` values (as these segment indices define the segmented data,
            and thus no strided-window rolling index calculation has to be executed).
            As such, the user can create variable-length segmented windows. However,
            in such cases, the user should be weary that the feature functions are
            invariant to these (potentially variable-length) windows.
    return_df : bool, optional
        Whether the output needs to be a DataFrame or a list thereof, by default
        False. If `True` the output dataframes will be merged to a DataFrame with an
        outer merge.
    window_idx : str, optional
        The window&#39;s index position which will be used as index for the
        feature_window aggregation. Must be either of: `[&#34;begin&#34;, &#34;middle&#34;, &#34;end&#34;]`.
        by **default &#34;end&#34;**. All features in this collection will use the same
        window_idx.

        ..Note::
            `window_idx`=&#34;end&#34; uses the window&#39;s end (= right open bound) as
            output index. \n
            `window_idx`=&#34;begin&#34; uses the window&#39;s start idx (= left closed bound)
            as output index.
    include_final_window : bool, optional
        Whether the final (possibly incomplete) window should be included in the
        strided-window segmentation, by default False.

        .. Note::
            The remarks below apply when `include_final_window` is set to True.
            The user should be aware that the last window *might* be incomplete,
            i.e.;

            - when equally sampled, the last window *might* be smaller than the
              the other windows.
            - when not equally sampled, the last window *might* not include all the
              data points (as the begin-time + window-size comes after the last data
              point).

            Note, that when equally sampled, the last window *will* be a full window
            when:

            - the stride is the sampling rate of the data (or stride = 1 for
            sample-based configurations).&lt;br&gt;
            **Remark**: that when `include_final_window` is set to False, the last
            window (which is a full) window will not be included!
            - *(len * sampling_rate - window_size) % stride = 0*. Remark that the
              above case is a base case of this.
    bound_method: str, optional
        The start-end bound methodology which is used to generate the slice ranges
        when ``data`` consists of multiple series / columns.
        Must be either of: `[&#34;inner&#34;, &#34;inner-outer&#34;, &#34;outer&#34;]`, by default &#34;inner&#34;.

        * if ``inner``, the inner-bounds of the series are returned.
        * if ``inner-outer``, the left-inner and right-outer bounds of the series
          are returned.
        * if ``outer``, the outer-bounds of the series are returned.
    approve_sparsity: bool, optional
        Bool indicating whether the user acknowledges that there may be sparsity
        (i.e., irregularly sampled data), by default False.
        If False and sparsity is observed, a warning is raised.
    show_progress: bool, optional
        If True, the progress will be shown with a progressbar, by default False.
    logging_file_path : Union[str, Path], optional
        The file path where the logged messages are stored. If `None`, then no
        logging `FileHandler` will be used and the logging messages are only pushed
        to stdout. Otherwise, a logging `FileHandler` will write the logged messages
        to the given file path. See also the `tsflex.features.logger` module.
    n_jobs : int, optional
        The number of processes used for the feature calculation. If `None`, then
        the number returned by _os.cpu_count()_ is used, by default None. \n
        If n_jobs is either 0 or 1, the code will be executed sequentially without
        creating a process pool. This is very useful when debugging, as the stack
        trace will be more comprehensible.
        .. note::
            Multiprocessed execution is not supported on Windows. Even when,
            `n_jobs` is set &gt; 1, the feature extraction will still be executed
            sequentially.
            Why do we not support multiprocessing on Windows; see this issue
            https://github.com/predict-idlab/tsflex/issues/51

        .. tip::
            It takes on avg. _300ms_ to schedule everything with
            multiprocessing. So if your sequential feature extraction code runs
            faster than ~1s, it might not be worth it to parallelize the process
            (and thus better leave `n_jobs` to 0 or 1).

    Returns
    -------
    Union[List[pd.DataFrame], pd.DataFrame]
        The calculated features.

    Raises
    ------
    KeyError
        Raised when a required key is not found in `data`.

    Notes
    ------
    * The (column-)names of the series in `data` represent the `series_names`.
    * If a `logging_file_path` is provided, the execution (time) info can be
      retrieved by calling `logger.get_feature_logs(logging_file_path)`.
      Be aware that the `logging_file_path` gets cleared before the logger pushes
      logged messages. Hence, one should use a separate logging file for each
      constructed processing and feature instance with this library.


    &#34;&#34;&#34;
    # Delete other logging handlers
    delete_logging_handlers(logger)
    # Add logging handler (if path provided)
    if logging_file_path:
        f_handler = add_logging_handler(logger, logging_file_path)

    # Convert to numpy array (if necessary)
    if segment_start_idxs is not None:
        segment_start_idxs = FeatureCollection._process_segment_idxs(
            segment_start_idxs
        )
    if segment_end_idxs is not None:
        segment_end_idxs = FeatureCollection._process_segment_idxs(segment_end_idxs)

    if segment_start_idxs is not None and segment_end_idxs is not None:
        # Check if segment indices have same length and whether every start idx
        # &lt;= end idx
        _check_start_end_array(segment_start_idxs, segment_end_idxs)
        # Check if there is either 1 or No(ne) window value for every output name -
        # input_series combination
        self._check_no_multiple_windows()

    if segment_start_idxs is None or segment_end_idxs is None:
        assert all(
            fd.window is not None
            for fd in flatten(self._feature_desc_dict.values())
        ), (
            &#34;Each feature descriptor must have a window when not both &#34;
            + &#34;segment_start_idxs and segment_end_idxs are provided&#34;
        )

    if stride is None and segment_start_idxs is None and segment_end_idxs is None:
        assert all(
            fd.stride is not None
            for fd in flatten(self._feature_desc_dict.values())
        ), (
            &#34;Each feature descriptor must have a stride when no stride or &#34;
            + &#34;segment indices are passed to this method!&#34;
        )
    elif stride is not None and (
        segment_start_idxs is not None or segment_end_idxs is not None
    ):
        raise ValueError(
            &#34;The stride and any segment index argument cannot be set together! &#34;
            + &#34;At least one of both should be None.&#34;
        )

    if stride is not None:
        # Verify whether the stride complies with the input data dtype
        stride = [
            parse_time_arg(s) if isinstance(s, str) else s for s in to_list(stride)
        ]
        self._check_feature_descriptors(skip_none=False, calc_stride=stride)

    # Convert the data to a series_dict
    series_dict: Dict[str, pd.Series] = {}
    for s in to_series_list(data):
        if not s.index.is_monotonic_increasing:
            warnings.warn(
                f&#34;The index of series &#39;{s.name}&#39; is not monotonic increasing. &#34;
                + &#34;The series will be sorted by the index.&#34;,
                RuntimeWarning,
            )
            s = s.sort_index(ascending=True, inplace=False, ignore_index=False)

        # Assert the assumptions we make!
        assert s.index.is_monotonic_increasing

        if s.name in self.get_required_series():
            series_dict[str(s.name)] = s

    # Determine the bounds of the series dict items and slice on them
    # TODO: is dit wel nodig `hier? want we doen dat ook in de strided rolling
    start, end = _determine_bounds(bound_method, list(series_dict.values()))
    series_dict = {
        n: s.loc[
            s.index.dtype.type(start) : s.index.dtype.type(end)
        ]  # TODO: check memory efficiency of ths
        for n, s, in series_dict.items()
    }

    # Note: this variable has a global scope so this is shared in multiprocessing
    # TODO: try to make this more efficient (but is not really the bottleneck)
    global get_stroll_func
    get_stroll_func = self._stroll_feat_generator(
        series_dict,
        calc_stride=stride,
        segment_start_idxs=segment_start_idxs,
        segment_end_idxs=segment_end_idxs,
        start_idx=start,
        end_idx=end,
        window_idx=window_idx,
        include_final_window=include_final_window,
        approve_sparsity=approve_sparsity,
    )
    nb_stroll_funcs = self._get_stroll_feat_length()

    if (
        os.name == &#34;nt&#34;
    ):  # On Windows no multiprocessing is supported, see https://github.com/predict-idlab/tsflex/issues/51
        n_jobs = 1
    elif n_jobs is None:
        n_jobs = os.cpu_count()
    n_jobs = min(n_jobs, nb_stroll_funcs)

    calculated_feature_list = None
    if n_jobs in [0, 1]:
        idxs = range(nb_stroll_funcs)
        if show_progress:
            idxs = tqdm(idxs)
        try:
            calculated_feature_list = [self._executor(idx) for idx in idxs]
        except Exception:
            traceback.print_exc()
    else:
        with Pool(processes=n_jobs) as pool:
            results = pool.imap_unordered(self._executor, range(nb_stroll_funcs))
            if show_progress:
                results = tqdm(results, total=nb_stroll_funcs)
            try:
                calculated_feature_list = [f for f in results]
            except Exception:
                traceback.print_exc()
                pool.terminate()
            finally:
                # Close &amp; join because: https://github.com/uqfoundation/pathos/issues/131
                pool.close()
                pool.join()

    # Close the file handler (this avoids PermissionError: [WinError 32])
    if logging_file_path:
        f_handler.close()
        logger.removeHandler(f_handler)

    if calculated_feature_list is None:
        raise RuntimeError(
            &#34;Feature Extraction halted due to error while extracting one &#34;
            + &#34;(or multiple) feature(s)! See stack trace above.&#34;
        )

    if return_df:
        # concatenate &amp; sort the columns
        df = pd.concat(calculated_feature_list, axis=1, join=&#34;outer&#34;, copy=False)
        return df.reindex(sorted(df.columns), axis=1)
    else:
        return calculated_feature_list</code></pre>
</details>
<div class="desc"><p>Calculate features on the passed data.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>Union[pd.Series, pd.DataFrame, List[Union[pd.Series, pd.DataFrame]]]</code></dt>
<dd>
<p>Dataframe or Series or list thereof, with all the required data for the
feature calculation. </p>
<p><strong>Assumptions</strong>: </p>
<ul>
<li>each Series / DataFrame must have a sortable index. This index represents
the sequence position of the corresponding values, the index can be either
numeric or a <code>pd.DatetimeIndex</code>.</li>
<li>each Series / DataFrame index must be comparable with all others</li>
<li>we assume that each series-name / dataframe-column-name is unique.</li>
</ul>
</dd>
<dt><strong><code>stride</code></strong> :&ensp;<code>Union[float, str, pd.Timedelta, List[Union[float, str, pd.Timedelta], None]</code>, optional</dt>
<dd>
<p>The stride size. By default None. This argument supports multiple types: </p>
<ul>
<li>If None, the stride of the <code><a title="tsflex.features.FeatureDescriptor" href="#tsflex.features.FeatureDescriptor">FeatureDescriptor</a></code> objects will be used.</li>
<li>
<p>If the type is an <code>float</code> or an <code>int</code>, its value represents the series:</p>
<ul>
<li>its stride <strong>range</strong> when a <strong>non time-indexed</strong> series is passed.</li>
<li>the stride in <strong>number of samples</strong>, when a <strong>time-indexed</strong> series
is passed (must then be and <code>int</code>)<ul>
<li>If the stride's type is a <code>pd.Timedelta</code>, the stride size represents
the stride-time delta. The passed data <strong>must have a time-index</strong>.</li>
<li>If a <code>str</code>, it must represent a stride-time-delta-string. Hence, the
<strong>passed data must have a time-index</strong>. </li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When set, this stride argument takes precedence over the stride property
of the <code><a title="tsflex.features.FeatureDescriptor" href="#tsflex.features.FeatureDescriptor">FeatureDescriptor</a></code>s in this <code><a title="tsflex.features.FeatureCollection" href="#tsflex.features.FeatureCollection">FeatureCollection</a></code> (i.e., when a
not None value for <code>stride</code> passed to this method).</p>
</div>
</dd>
<dt><strong><code>segment_start_idxs</code></strong> :&ensp;<code>Union[list, np.ndarray, pd.Series, pd.Index]</code>, optional</dt>
<dd>
<p>The start indices of the segments. If None, the start indices will be
computed from the data using either:</p>
<ul>
<li>the <code>segment_end_idxs</code> - the <code>window</code> size property of the
<code><a title="tsflex.features.FeatureDescriptor" href="#tsflex.features.FeatureDescriptor">FeatureDescriptor</a></code> in this <code><a title="tsflex.features.FeatureCollection" href="#tsflex.features.FeatureCollection">FeatureCollection</a></code> (if <code>segment_end_idxs</code>
is not None)</li>
<li>strided-window rolling on the data using <code>window</code> and <code>stride</code> of the
<code><a title="tsflex.features.FeatureDescriptor" href="#tsflex.features.FeatureDescriptor">FeatureDescriptor</a></code> in this <code><a title="tsflex.features.FeatureCollection" href="#tsflex.features.FeatureCollection">FeatureCollection</a></code> (if <code>segment_end_idxs</code>
is also None). (Note that the <code>stride</code> argument of this method takes
precedence over the <code>stride</code> property of the <code><a title="tsflex.features.FeatureDescriptor" href="#tsflex.features.FeatureDescriptor">FeatureDescriptor</a></code>s).
By default None.</li>
</ul>
</dd>
<dt><strong><code>segment_end_idxs</code></strong> :&ensp;<code>Union[list, np.ndarray, pd.Series, pd.Index]</code>, optional</dt>
<dd>
<p>The end indices for the segmented windows. If None, the end indices will be
computed from the data using either:</p>
<ul>
<li>the <code>segment_start_idxs</code> + the <code>window</code> size property of the
<code><a title="tsflex.features.FeatureDescriptor" href="#tsflex.features.FeatureDescriptor">FeatureDescriptor</a></code> in this <code><a title="tsflex.features.FeatureCollection" href="#tsflex.features.FeatureCollection">FeatureCollection</a></code> (if <code>segment_start_idxs</code>
is not None)</li>
<li>strided-window rolling on the data using <code>window</code> and <code>stride</code> of the
<code><a title="tsflex.features.FeatureDescriptor" href="#tsflex.features.FeatureDescriptor">FeatureDescriptor</a></code> in this <code><a title="tsflex.features.FeatureCollection" href="#tsflex.features.FeatureCollection">FeatureCollection</a></code> (if <code>segment_start_idxs</code>
is also None). (Note that the <code>stride</code> argument of this method takes
precedence over the <code>stride</code> property of the <code><a title="tsflex.features.FeatureDescriptor" href="#tsflex.features.FeatureDescriptor">FeatureDescriptor</a></code>s).
By default None.</li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When passing both <code>segment_start_idxs</code> and <code>segment_end_idxs</code>, these two
arguments must have the same length and every start index must be &lt;=
than the corresponding end index.
Note that passing both arguments, discards any meaning of the <code>window</code>
and <code>stride</code> values (as these segment indices define the segmented data,
and thus no strided-window rolling index calculation has to be executed).
As such, the user can create variable-length segmented windows. However,
in such cases, the user should be weary that the feature functions are
invariant to these (potentially variable-length) windows.</p>
</div>
</dd>
<dt><strong><code>return_df</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether the output needs to be a DataFrame or a list thereof, by default
False. If <code>True</code> the output dataframes will be merged to a DataFrame with an
outer merge.</dd>
<dt><strong><code>window_idx</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>
<p>The window's index position which will be used as index for the
feature_window aggregation. Must be either of: <code>["begin", "middle", "end"]</code>.
by <strong>default "end"</strong>. All features in this collection will use the same
window_idx.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code>window_idx</code>="end" uses the window's end (= right open bound) as
output index. </p>
<p><code>window_idx</code>="begin" uses the window's start idx (= left closed bound)
as output index.</p>
</div>
</dd>
<dt><strong><code>include_final_window</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>
<p>Whether the final (possibly incomplete) window should be included in the
strided-window segmentation, by default False.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The remarks below apply when <code>include_final_window</code> is set to True.
The user should be aware that the last window <em>might</em> be incomplete,
i.e.;</p>
<ul>
<li>when equally sampled, the last window <em>might</em> be smaller than the
the other windows.</li>
<li>when not equally sampled, the last window <em>might</em> not include all the
data points (as the begin-time + window-size comes after the last data
point).</li>
</ul>
<p>Note, that when equally sampled, the last window <em>will</em> be a full window
when:</p>
<ul>
<li>the stride is the sampling rate of the data (or stride = 1 for
sample-based configurations).<br>
<strong>Remark</strong>: that when <code>include_final_window</code> is set to False, the last
window (which is a full) window will not be included!</li>
<li><em>(len * sampling_rate - window_size) % stride = 0</em>. Remark that the
above case is a base case of this.</li>
</ul>
</div>
</dd>
<dt><strong><code>bound_method</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>
<p>The start-end bound methodology which is used to generate the slice ranges
when <code>data</code> consists of multiple series / columns.
Must be either of: <code>["inner", "inner-outer", "outer"]</code>, by default "inner".</p>
<ul>
<li>if <code>inner</code>, the inner-bounds of the series are returned.</li>
<li>if <code>inner-outer</code>, the left-inner and right-outer bounds of the series
are returned.</li>
<li>if <code>outer</code>, the outer-bounds of the series are returned.</li>
</ul>
</dd>
<dt><strong><code>approve_sparsity</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Bool indicating whether the user acknowledges that there may be sparsity
(i.e., irregularly sampled data), by default False.
If False and sparsity is observed, a warning is raised.</dd>
<dt><strong><code>show_progress</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If True, the progress will be shown with a progressbar, by default False.</dd>
<dt><strong><code>logging_file_path</code></strong> :&ensp;<code>Union[str, Path]</code>, optional</dt>
<dd>The file path where the logged messages are stored. If <code>None</code>, then no
logging <code>FileHandler</code> will be used and the logging messages are only pushed
to stdout. Otherwise, a logging <code>FileHandler</code> will write the logged messages
to the given file path. See also the <code><a title="tsflex.features.logger" href="logger.html">.logger</a></code> module.</dd>
<dt><strong><code>n_jobs</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>
<p>The number of processes used for the feature calculation. If <code>None</code>, then
the number returned by <em>os.cpu_count()</em> is used, by default None. </p>
<p>If n_jobs is either 0 or 1, the code will be executed sequentially without
creating a process pool. This is very useful when debugging, as the stack
trace will be more comprehensible.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Multiprocessed execution is not supported on Windows. Even when,
<code>n_jobs</code> is set &gt; 1, the feature extraction will still be executed
sequentially.
Why do we not support multiprocessing on Windows; see this issue
<a href="https://github.com/predict-idlab/tsflex/issues/51">https://github.com/predict-idlab/tsflex/issues/51</a></p>
</div>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>It takes on avg. <em>300ms</em> to schedule everything with
multiprocessing. So if your sequential feature extraction code runs
faster than ~1s, it might not be worth it to parallelize the process
(and thus better leave <code>n_jobs</code> to 0 or 1).</p>
</div>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Union[List[pd.DataFrame], pd.DataFrame]</code></dt>
<dd>The calculated features.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>KeyError</code></dt>
<dd>Raised when a required key is not found in <code>data</code>.</dd>
</dl>
<h2 id="notes">Notes</h2>
<ul>
<li>The (column-)names of the series in <code>data</code> represent the <code>series_names</code>.</li>
<li>If a <code>logging_file_path</code> is provided, the execution (time) info can be
retrieved by calling <code><a title="tsflex.features.logger.get_feature_logs" href="logger.html#tsflex.features.logger.get_feature_logs">get_feature_logs()</a>(logging_file_path)</code>.
Be aware that the <code>logging_file_path</code> gets cleared before the logger pushes
logged messages. Hence, one should use a separate logging file for each
constructed processing and feature instance with this library.</li>
</ul></div>
</dd>
<dt id="tsflex.features.FeatureCollection.serialize"><code class="name flex">
<span>def <span class="ident">serialize</span></span>(<span>self, file_path)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def serialize(self, file_path: Union[str, Path]):
    &#34;&#34;&#34;Serialize this FeatureCollection instance.

    Parameters
    ----------
    file_path : Union[str, Path]
        The path where the `FeatureCollection` will be serialized.

    Note
    -----
    As we use [Dill](https://github.com/uqfoundation/dill){:target=&#34;_blank&#34;} to
    serialize the files, we can **also serialize functions which are defined in
    the local scope, like lambdas.**

    &#34;&#34;&#34;
    with open(file_path, &#34;wb&#34;) as f:
        dill.dump(self, f, recurse=True)</code></pre>
</details>
<div class="desc"><p>Serialize this FeatureCollection instance.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>file_path</code></strong> :&ensp;<code>Union[str, Path]</code></dt>
<dd>The path where the <code><a title="tsflex.features.FeatureCollection" href="#tsflex.features.FeatureCollection">FeatureCollection</a></code> will be serialized.</dd>
</dl>
<h2 id="note">Note</h2>
<p>As we use <a href="https://github.com/uqfoundation/dill" target="_blank">Dill</a> to
serialize the files, we can <strong>also serialize functions which are defined in
the local scope, like lambdas.</strong></p></div>
</dd>
<dt id="tsflex.features.FeatureCollection.reduce"><code class="name flex">
<span>def <span class="ident">reduce</span></span>(<span>self, feat_cols_to_keep)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reduce(self, feat_cols_to_keep: List[str]) -&gt; FeatureCollection:
    &#34;&#34;&#34;Create a reduced FeatureCollection instance based on `feat_cols_to_keep`.

    For example, this is useful to optimize feature-extraction inference
    (for your selected features) after performing a feature-selection procedure.

    Parameters
    ----------
    feat_cols_to_keep: List[str]
        A subset of the feature collection instance its column names.
        This corresponds to the columns / names of the output from `calculate`
        method that you want to keep.

    Returns
    -------
    FeatureCollection
        A new FeatureCollection object, which only withholds the FeatureDescriptors
        which constitute the `feat_cols_to_keep` output.

    Note
    ----
    Some FeatureDescriptor objects may have multiple **output-names**.&lt;br&gt;
    Hence, if you only want to retain _a subset_ of that FeatureDescriptor its
    feature outputs, you will still get **all features** as the new
    FeatureCollection is constructed by applying a filter on de FeatureDescriptor
    list and we thus not alter these FeatureDescriptor objects themselves.

    &#34;&#34;&#34;
    # dict in which we store all the { output_col_name : (UUID, FeatureDescriptor) }
    # items of our current FeatureCollection object
    manual_window = False
    if any(c.endswith(&#34;w=manual&#34;) for c in feat_cols_to_keep):
        assert all(c.endswith(&#34;w=manual&#34;) for c in feat_cols_to_keep)
        # As the windows are created manual, the FeatureCollection cannot contain
        # multiple windows for the same output name - input_series combination
        self._check_no_multiple_windows()
        manual_window = True
    feat_col_fd_mapping: Dict[str, Tuple[str, FeatureDescriptor]] = {}
    for (s_names, window), fd_list in self._feature_desc_dict.items():
        window = &#34;manual&#34; if manual_window else self._ws_to_str(window)
        for fd in fd_list:
            # As a single FeatureDescriptor can have multiple output col names, we
            # create a unique identifier for each FeatureDescriptor (on which we
            # will apply set-like operations later on to only retain all the unique
            # FeatureDescriptors)
            uuid_str = str(uuid.uuid4())
            for output_name in fd.function.output_names:
                # Reconstruct the feature column name
                feat_col_name = StridedRolling.construct_output_index(
                    series_keys=s_names, feat_name=output_name, win_str=window
                )
                feat_col_fd_mapping[feat_col_name] = (uuid_str, fd)

    assert all(fc in feat_col_fd_mapping for fc in feat_cols_to_keep)

    # Collect (uuid, FeatureDescriptor) for the feat_cols_to_keep
    fd_subset: List[Tuple[str, FeatureDescriptor]] = [
        feat_col_fd_mapping[fc] for fc in feat_cols_to_keep
    ]

    # Reduce to unique feature descriptor objects (based on uuid) and create a new
    # FeatureCollection for their deepcopy&#39;s.
    seen_uuids = set()
    return FeatureCollection(
        feature_descriptors=[
            deepcopy(unique_fd)
            for unique_fd in {
                fd
                for (uuid_str, fd) in fd_subset
                if uuid_str not in seen_uuids and not seen_uuids.add(uuid_str)
            }
        ]
    )</code></pre>
</details>
<div class="desc"><p>Create a reduced FeatureCollection instance based on <code>feat_cols_to_keep</code>.</p>
<p>For example, this is useful to optimize feature-extraction inference
(for your selected features) after performing a feature-selection procedure.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>feat_cols_to_keep</code></strong> :&ensp;<code>List[str]</code></dt>
<dd>A subset of the feature collection instance its column names.
This corresponds to the columns / names of the output from <code>calculate</code>
method that you want to keep.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="tsflex.features.FeatureCollection" href="#tsflex.features.FeatureCollection">FeatureCollection</a></code></dt>
<dd>A new FeatureCollection object, which only withholds the FeatureDescriptors
which constitute the <code>feat_cols_to_keep</code> output.</dd>
</dl>
<h2 id="note">Note</h2>
<p>Some FeatureDescriptor objects may have multiple <strong>output-names</strong>.<br>
Hence, if you only want to retain <em>a subset</em> of that FeatureDescriptor its
feature outputs, you will still get <strong>all features</strong> as the new
FeatureCollection is constructed by applying a filter on de FeatureDescriptor
list and we thus not alter these FeatureDescriptor objects themselves.</p></div>
</dd>
</dl>
</dd>
<dt id="tsflex.features.FuncWrapper"><code class="flex name class">
<span>class <span class="ident">FuncWrapper</span></span>
<span>(</span><span>func, output_names=None, input_type=&lt;built-in function array&gt;, vectorized=False, **kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FuncWrapper(FrozenClass):
    &#34;&#34;&#34;Function wrapper.

    A function wrapper which takes a numpy array / pandas series as input and returns
    one or multiple values. It also defines the names of the function outputs, and
    stores the function its keyword arguments.

    Parameters
    ----------
    func : Callable
        The wrapped function.
    output_names : Union[List[str], str], optional
        The name of the outputs of the function, by default None.
    input_type: Union[np.array, pd.Series], optional
        The input type that the function requires (either np.array or pd.Series), by
        default np.array.
        .. Note::
            Make sure to only set this argument to pd.Series if the function requires
            a pd.Series, since pd.Series strided-rolling is significantly less efficient.
            For a np.array it is possible to create very efficient views, but there is no
            such thing as a pd.Series view. Thus, for each stroll, a new series is created.
    vectorized: bool, optional
        Flag indicating whether `func` should be executed vectorized over all the
        segmented windows, by default False.
        .. Info::
            A vectorized function should take one or multiple series that each have the
            shape (nb. segmented windows, window size).
            For example a vectorized version of `np.max` is
            ``FuncWrapper(np.max, vectorized=True, axis=1)``.
        .. Note::
            * A function can only be applied in vectorized manner when the required
              series are REGULARLY sampled (and have the same index in case of multiple
              required series).
            * The `input_type` should be `np.array` when `vectorized` is True. It does
              not make sense to use a `pd.Series`, as the index should be regularly
              sampled (see requirement above).
    **kwargs: dict, optional
        Keyword arguments which will be also passed to the `function`

    Raises
    ------
    TypeError
        Raised when the `output_names` cannot be set.

    &#34;&#34;&#34;

    def __init__(
        self,
        func: Callable,
        output_names: Optional[Union[List[str], str]] = None,
        input_type: Optional[Union[np.array, pd.Series]] = np.array,
        vectorized: bool = False,
        **kwargs,
    ):
        &#34;&#34;&#34;Create FuncWrapper instance.&#34;&#34;&#34;
        self.func = func
        self.kwargs: dict = kwargs

        if isinstance(output_names, list):
            self.output_names = output_names
        elif isinstance(output_names, str):
            self.output_names = [output_names]
        elif not output_names:
            self.output_names = [_get_name(func)]
        else:
            raise TypeError(f&#34;`output_names` is unexpected type {type(output_names)}&#34;)

        assert input_type in SUPPORTED_STROLL_TYPES, &#34;Invalid input_type!&#34;
        assert not (
            vectorized &amp; (input_type is not np.array)
        ), &#34;The input_type must be np.array if vectorized is True!&#34;
        self.input_type = input_type
        self.vectorized = vectorized

        self._freeze()

    def __repr__(self) -&gt; str:
        &#34;&#34;&#34;Return repr string.&#34;&#34;&#34;
        return (
            f&#34;{self.__class__.__name__}({_get_name(self.func)}, {self.output_names},&#34;
            f&#34; {self.kwargs})&#34;
        )

    def __call__(self, *series: Union[np.ndarray, pd.Series]) -&gt; Any:
        &#34;&#34;&#34;Call wrapped function with passed data.

        Parameters
        ---------
        *series : Union[np.ndarray, pd.Series]
            The (multiple) input series for the function.

        Returns
        -------
        Any
            The function output for the passed series.

        &#34;&#34;&#34;
        return self.func(*series, **self.kwargs)</code></pre>
</details>
<div class="desc"><p>Function wrapper.</p>
<p>A function wrapper which takes a numpy array / pandas series as input and returns
one or multiple values. It also defines the names of the function outputs, and
stores the function its keyword arguments.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>func</code></strong> :&ensp;<code>Callable</code></dt>
<dd>The wrapped function.</dd>
<dt><strong><code>output_names</code></strong> :&ensp;<code>Union[List[str], str]</code>, optional</dt>
<dd>The name of the outputs of the function, by default None.</dd>
<dt><strong><code>input_type</code></strong> :&ensp;<code>Union[np.array, pd.Series]</code>, optional</dt>
<dd>The input type that the function requires (either np.array or pd.Series), by
default np.array.<div class="admonition note">
<p class="admonition-title">Note</p>
Make sure to only set this argument to pd.Series if the function requires
a pd.Series, since pd.Series strided-rolling is significantly less efficient.
For a np.array it is possible to create very efficient views, but there is no
such thing as a pd.Series view. Thus, for each stroll, a new series is created.</div>
</dd>
<dt><strong><code>vectorized</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>
<p>Flag indicating whether <code>func</code> should be executed vectorized over all the
segmented windows, by default False.</p>
<div class="admonition info">
<p class="admonition-title">Info</p>
A vectorized function should take one or multiple series that each have the
shape (nb. segmented windows, window size).
For example a vectorized version of <code>np.max</code> is
<code>FuncWrapper(np.max, vectorized=True, axis=1)</code>.</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ul>
<li>A function can only be applied in vectorized manner when the required
series are REGULARLY sampled (and have the same index in case of multiple
required series).</li>
<li>The <code>input_type</code> should be <code>np.array</code> when <code>vectorized</code> is True. It does
not make sense to use a <code>pd.Series</code>, as the index should be regularly
sampled (see requirement above).</li>
</ul>
</div>
</dd>
<dt><strong><code>**kwargs</code></strong> :&ensp;<code>dict</code>, optional</dt>
<dd>Keyword arguments which will be also passed to the <code>function</code></dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>Raised when the <code>output_names</code> cannot be set.</dd>
</dl>
<p>Create FuncWrapper instance.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>tsflex.utils.classes.FrozenClass</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="tsflex.features.FuncWrapper.__call__"><code class="name flex">
<span>def <span class="ident">__call__</span></span>(<span>self, *series)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __call__(self, *series: Union[np.ndarray, pd.Series]) -&gt; Any:
    &#34;&#34;&#34;Call wrapped function with passed data.

    Parameters
    ---------
    *series : Union[np.ndarray, pd.Series]
        The (multiple) input series for the function.

    Returns
    -------
    Any
        The function output for the passed series.

    &#34;&#34;&#34;
    return self.func(*series, **self.kwargs)</code></pre>
</details>
<div class="desc"><p>Call wrapped function with passed data.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>*series</code></strong> :&ensp;<code>Union[np.ndarray, pd.Series]</code></dt>
<dd>The (multiple) input series for the function.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Any</code></dt>
<dd>The function output for the passed series.</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="tsflex.features.StridedRollingFactory"><code class="flex name class">
<span>class <span class="ident">StridedRollingFactory</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StridedRollingFactory:
    &#34;&#34;&#34;Factory class for creating the appropriate StridedRolling segmenter.&#34;&#34;&#34;

    _datatype_to_stroll = {
        DataType.TIME: TimeStridedRolling,
        DataType.SEQUENCE: SequenceStridedRolling,
    }

    @staticmethod
    def get_segmenter(data, window, strides, **kwargs) -&gt; StridedRolling:
        &#34;&#34;&#34;Get the appropriate StridedRolling instance for the passed data.

        The returned instance will be determined by the data its index type

        Parameters
        ----------
        data : Union[pd.Series, pd.DataFrame, List[Union[pd.Series, pd.DataFrame]]]
            The data to segment.
        window : Union[float, pd.TimeDelta]
             The window size to use for the segmentation.
        strides : Union[List[Union[float, pd.TimeDelta]], None]
            The stride(s) to use for the segmentation.
        **kwargs : dict, optional
            Additional keyword arguments, see the `StridedRolling` its documentation
            for more info.

        .. Note::
            When passing `time-based` data, but **int**-based window &amp; stride params,
            the strided rolling will be `TimeIndexSampleStridedRolling`. This class
            **assumes** that **all data series** _roughly_ have the
            **same sample frequency**, as  the windows and strides are interpreted in
            terms of **number of samples**.

        Raises
        ------
        ValueError
            When incompatible data &amp; window-stride data types are passed (e.g. time
            window-stride args on sequence data-index).

        Returns
        -------
        StridedRolling
            The constructed StridedRolling instance.

        &#34;&#34;&#34;
        data_dtype = AttributeParser.determine_type(data)
        if strides is None:
            args_dtype = AttributeParser.determine_type(window)
        else:
            args_dtype = AttributeParser.determine_type([window] + strides)

        if window is None or data_dtype.value == args_dtype.value:
            return StridedRollingFactory._datatype_to_stroll[data_dtype](
                data, window, strides, **kwargs
            )
        elif data_dtype == DataType.TIME and args_dtype == DataType.SEQUENCE:
            # Note: this is very niche and thus requires advanced knowledge
            return TimeIndexSampleStridedRolling(data, window, strides, **kwargs)
        elif data_dtype == DataType.SEQUENCE and args_dtype == DataType.TIME:
            raise ValueError(&#34;Cannot segment a sequence-series with a time window&#34;)</code></pre>
</details>
<div class="desc"><p>Factory class for creating the appropriate StridedRolling segmenter.</p></div>
<h3>Static methods</h3>
<dl>
<dt id="tsflex.features.StridedRollingFactory.get_segmenter"><code class="name flex">
<span>def <span class="ident">get_segmenter</span></span>(<span>data, window, strides, **kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def get_segmenter(data, window, strides, **kwargs) -&gt; StridedRolling:
    &#34;&#34;&#34;Get the appropriate StridedRolling instance for the passed data.

    The returned instance will be determined by the data its index type

    Parameters
    ----------
    data : Union[pd.Series, pd.DataFrame, List[Union[pd.Series, pd.DataFrame]]]
        The data to segment.
    window : Union[float, pd.TimeDelta]
         The window size to use for the segmentation.
    strides : Union[List[Union[float, pd.TimeDelta]], None]
        The stride(s) to use for the segmentation.
    **kwargs : dict, optional
        Additional keyword arguments, see the `StridedRolling` its documentation
        for more info.

    .. Note::
        When passing `time-based` data, but **int**-based window &amp; stride params,
        the strided rolling will be `TimeIndexSampleStridedRolling`. This class
        **assumes** that **all data series** _roughly_ have the
        **same sample frequency**, as  the windows and strides are interpreted in
        terms of **number of samples**.

    Raises
    ------
    ValueError
        When incompatible data &amp; window-stride data types are passed (e.g. time
        window-stride args on sequence data-index).

    Returns
    -------
    StridedRolling
        The constructed StridedRolling instance.

    &#34;&#34;&#34;
    data_dtype = AttributeParser.determine_type(data)
    if strides is None:
        args_dtype = AttributeParser.determine_type(window)
    else:
        args_dtype = AttributeParser.determine_type([window] + strides)

    if window is None or data_dtype.value == args_dtype.value:
        return StridedRollingFactory._datatype_to_stroll[data_dtype](
            data, window, strides, **kwargs
        )
    elif data_dtype == DataType.TIME and args_dtype == DataType.SEQUENCE:
        # Note: this is very niche and thus requires advanced knowledge
        return TimeIndexSampleStridedRolling(data, window, strides, **kwargs)
    elif data_dtype == DataType.SEQUENCE and args_dtype == DataType.TIME:
        raise ValueError(&#34;Cannot segment a sequence-series with a time window&#34;)</code></pre>
</details>
<div class="desc"><p>Get the appropriate StridedRolling instance for the passed data.</p>
<p>The returned instance will be determined by the data its index type</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>Union[pd.Series, pd.DataFrame, List[Union[pd.Series, pd.DataFrame]]]</code></dt>
<dd>The data to segment.</dd>
<dt><strong><code>window</code></strong> :&ensp;<code>Union[float, pd.TimeDelta]</code></dt>
<dd>The window size to use for the segmentation.</dd>
<dt><strong><code>strides</code></strong> :&ensp;<code>Union[List[Union[float, pd.TimeDelta]], None]</code></dt>
<dd>The stride(s) to use for the segmentation.</dd>
<dt><strong><code>**kwargs</code></strong> :&ensp;<code>dict</code>, optional</dt>
<dd>Additional keyword arguments, see the <code>StridedRolling</code> its documentation
for more info.</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When passing <code>time-based</code> data, but <strong>int</strong>-based window &amp; stride params,
the strided rolling will be <code>TimeIndexSampleStridedRolling</code>. This class
<strong>assumes</strong> that <strong>all data series</strong> <em>roughly</em> have the
<strong>same sample frequency</strong>, as
the windows and strides are interpreted in
terms of <strong>number of samples</strong>.</p>
</div>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>When incompatible data &amp; window-stride data types are passed (e.g. time
window-stride args on sequence data-index).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>StridedRolling</code></dt>
<dd>The constructed StridedRolling instance.</dd>
</dl></div>
</dd>
</dl>
</dd>
</dl>
</section>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</article>
<div class="sidebar_container">
<nav id="sidebar">
<div id="sidebar_content">
<header>
<div style="text-align: left; padding-top: 15px;">
<a class="homelink" rel="home" title="tsflex home" href="/tsflex/">
<img src="https://raw.githubusercontent.com/predict-idlab/tsflex/main/docs/_static/logo.png"
alt="logo should be displayed here" width="95%"></a>
</div>
</header>
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#feature-extraction-guide">Feature extraction guide</a><ul>
<li><a href="#working-example">Working example ✅</a></li>
<li><a href="#getting-started">Getting started 🚀</a><ul>
<li><a href="#components">Components</a></li>
<li><a href="#feature-functions">Feature functions</a></li>
<li><a href="#multiple-feature-descriptors">Multiple feature descriptors</a></li>
<li><a href="#output-format">Output format</a></li>
</ul>
</li>
<li><a href="#limitations">Limitations ⚠️</a></li>
<li><a href="#important-notes">Important notes 📢</a></li>
<li><a href="#advanced-usage">Advanced usage 👀</a><ul>
<li><a href="#versatile-functions">Versatile functions</a></li>
<li><a href="#multivariate-data">Multivariate-data</a></li>
<li><a href="#irregularly-sampled-data">Irregularly sampled data</a></li>
<li><a href="#logging">Logging</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="tsflex" href="../index.html">tsflex</a></code></li>
</ul>
</li>
<li><h3><a href="#header-submodules">tsflex.features: API reference</a></h3>
<ul>
<li><code><a title="tsflex.features.feature" href="feature.html">.feature</a></code></li>
<li><code><a title="tsflex.features.feature_collection" href="feature_collection.html">.feature_collection</a></code></li>
<li><code><a title="tsflex.features.function_wrapper" href="function_wrapper.html">.function_wrapper</a></code></li>
<li><code><a title="tsflex.features.integrations" href="integrations.html">.integrations</a></code></li>
<li><code><a title="tsflex.features.logger" href="logger.html">.logger</a></code></li>
<li><code><a title="tsflex.features.segmenter" href="segmenter/index.html">.segmenter</a></code></li>
<li><code><a title="tsflex.features.utils" href="utils.html">.utils</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="tsflex.features.get_feature_logs" href="#tsflex.features.get_feature_logs">get_feature_logs</a></code></li>
<li><code><a title="tsflex.features.get_function_stats" href="#tsflex.features.get_function_stats">get_function_stats</a></code></li>
<li><code><a title="tsflex.features.get_series_names_stats" href="#tsflex.features.get_series_names_stats">get_series_names_stats</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="tsflex.features.FeatureDescriptor" href="#tsflex.features.FeatureDescriptor">FeatureDescriptor</a></code></h4>
<ul class="">
<li><code><a title="tsflex.features.FeatureDescriptor.get_required_series" href="#tsflex.features.FeatureDescriptor.get_required_series">get_required_series</a></code></li>
<li><code><a title="tsflex.features.FeatureDescriptor.get_nb_output_features" href="#tsflex.features.FeatureDescriptor.get_nb_output_features">get_nb_output_features</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tsflex.features.MultipleFeatureDescriptors" href="#tsflex.features.MultipleFeatureDescriptors">MultipleFeatureDescriptors</a></code></h4>
</li>
<li>
<h4><code><a title="tsflex.features.FeatureCollection" href="#tsflex.features.FeatureCollection">FeatureCollection</a></code></h4>
<ul class="">
<li><code><a title="tsflex.features.FeatureCollection.get_required_series" href="#tsflex.features.FeatureCollection.get_required_series">get_required_series</a></code></li>
<li><code><a title="tsflex.features.FeatureCollection.get_nb_output_features" href="#tsflex.features.FeatureCollection.get_nb_output_features">get_nb_output_features</a></code></li>
<li><code><a title="tsflex.features.FeatureCollection.add" href="#tsflex.features.FeatureCollection.add">add</a></code></li>
<li><code><a title="tsflex.features.FeatureCollection.calculate" href="#tsflex.features.FeatureCollection.calculate">calculate</a></code></li>
<li><code><a title="tsflex.features.FeatureCollection.serialize" href="#tsflex.features.FeatureCollection.serialize">serialize</a></code></li>
<li><code><a title="tsflex.features.FeatureCollection.reduce" href="#tsflex.features.FeatureCollection.reduce">reduce</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tsflex.features.FuncWrapper" href="#tsflex.features.FuncWrapper">FuncWrapper</a></code></h4>
<ul class="">
<li><code><a title="tsflex.features.FuncWrapper.__call__" href="#tsflex.features.FuncWrapper.__call__">__call__</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tsflex.features.StridedRollingFactory" href="#tsflex.features.StridedRollingFactory">StridedRollingFactory</a></code></h4>
<ul class="">
<li><code><a title="tsflex.features.StridedRollingFactory.get_segmenter" href="#tsflex.features.StridedRollingFactory.get_segmenter">get_segmenter</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</nav>
</div>
</main>
<script>
const sidebar = document.querySelector("body > main > div");
const sidebar_nav = document.querySelector("body > main > div > nav");
const sidebar_content = document.getElementById("sidebar_content");
document.getElementById("index_button_button").onclick = function () {
sidebar.classList.toggle('sidebar_small');
sidebar_nav.classList.toggle('hide_content');
sidebar_content.classList.toggle('hide_content');
}
</script>
</body>
</html>