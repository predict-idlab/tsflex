<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>tsflex.features.utils API documentation</title>
<meta name="description" content="Utility functions for more convenient feature extraction." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/foundation.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em;padding-left:1em;padding-right:1em}button{display:none}#sidebar{padding:3px;max-width:20em;overflow:hidden;min-width:19.8em}#sidebar > *:last-child{margin-bottom:1cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;border-top:1px solid #ddd;text-align:right}#footer p{}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f1f3f9;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:0.5em;padding:0px}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;max_width:100%;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.info{background:#edfcf4}.admonition.note,.admonition.important{background:#ebf3ff}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#edfcf4}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#ffddcc}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:850px){.sidebar_container{display:flex;transition:0.75s ease}.sidebar_small{width:0;margin:0;padding:0}.hide_content{display:none}button{display:initial;float:left;position:sticky;border:none;height:5ch;width:5ch;border-radius:50%;box-shadow:0px 1px 4px 1px rgba(0,0,0,.2);top:5%;left:100%;transform:translateX(-50%);cursor:pointer}#sidebar{width:25%;height:100vh;overflow:auto;position:sticky;top:0;transition:0.75s ease}#index_button_img{opacity:0.65}#content{max-width:105ch;padding:2em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1em;padding-right:0.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-212611910-1"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-212611910-1');
</script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
<link rel="icon" href="https://media.discordapp.net/attachments/372491075153166338/852906324417445908/icon.png">
</head>
<body>
<main>
<article id="content">
<button id="index_button_button"><img id="index_button_img"
src="https://image.flaticon.com/icons/png/512/56/56763.png"
alt="" width="33" height="25"></button>
<header>
<h1 class="title">Module <code>tsflex.features.utils</code></h1>
</header>
<section id="section-intro">
<p>Utility functions for more convenient feature extraction.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Utility functions for more convenient feature extraction.&#34;&#34;&#34;

__author__ = &#34;Jeroen Van Der Donckt, Jonas Van Der Donckt&#34;

import time
from typing import Any, Callable, Dict, List, Optional, Tuple, TypeVar, Union

import numpy as np
import pandas as pd

from .function_wrapper import FuncWrapper, _get_name
from .logger import logger

# Declare a type variable
T = TypeVar(&#34;T&#34;)

# ---------------------------------- PRIVATE METHODS ----------------------------------
def _process_func_output(
    out: np.ndarray, index: np.ndarray, output_names: List[str], func_str: str
) -&gt; Dict[str, np.ndarray]:
    &#34;&#34;&#34;Process the output of a feature function into a dictionary.&#34;&#34;&#34;
    feat_out = {}
    if out.ndim == 1 and not len(out):
        # When there are no features calculated (due to no feature windows)
        assert not len(index)
        for o_name in output_names:
            # Will be discarded (bc no index)
            feat_out[o_name] = None
    elif out.ndim == 1 or (out.ndim == 2 and out.shape[1] == 1):
        assert len(output_names) == 1, f&#34;Func {func_str} returned more than 1 output!&#34;
        feat_out[output_names[0]] = out.flatten()
    else:
        assert out.ndim == 2 and out.shape[1] &gt; 1
        assert (
            len(output_names) == out.shape[1]
        ), f&#34;Func {func_str} returned incorrect number of outputs ({out.shape[1]})!&#34;
        for col_idx in range(out.shape[1]):
            feat_out[output_names[col_idx]] = out[:, col_idx]

    return feat_out


def _log_func_execution(
    t_start: float,
    func: FuncWrapper,
    series_key: Tuple[str],
    log_window: Optional[T],
    log_strides: Optional[Union[str, Tuple[str]]],
    output_names: List[str],
):
    &#34;&#34;&#34;Log the execution time of a feature function.&#34;&#34;&#34;
    elapsed = time.perf_counter() - t_start

    logger.info(
        f&#34;Finished function [{_get_name(func.func)}] on &#34;
        f&#34;{[series_key]} with window-stride [{log_window}, {log_strides}] &#34;
        f&#34;with output {output_names} in [{elapsed} seconds]!&#34;
    )


def _determine_bounds(bound_method, series_list: List[pd.Series]) -&gt; Tuple[Any, Any]:
    &#34;&#34;&#34;Determine the bounds of the passed series.

    Parameters
    ----------
    bound_method: str

    series_list : List[pd.Series]
        The list of series for which the bounds are determined.

    Returns
    -------
    Tuple[pd.Timestamp, pd.Timestamp]
        The start &amp; end timestamp, respectively.

    &#34;&#34;&#34;
    if bound_method == &#34;inner&#34;:
        latest_start = series_list[0].index[0]
        earliest_stop = series_list[0].index[-1]
        for series in series_list[1:]:
            latest_start = max(latest_start, series.index[0])
            earliest_stop = min(earliest_stop, series.index[-1])
        return latest_start, earliest_stop
    elif bound_method == &#34;inner-outer&#34;:
        latest_start = series_list[0].index[0]
        latest_stop = series_list[0].index[-1]
        for series in series_list[1:]:
            latest_start = max(latest_start, series.index[0])
            latest_stop = max(latest_stop, series.index[-1])
        return latest_start, latest_stop
    elif bound_method == &#34;outer&#34;:
        earliest_start = series_list[0].index[0]
        latest_stop = series_list[0].index[-1]
        for series in series_list[1:]:
            earliest_start = min(earliest_start, series.index[0])
            latest_stop = max(latest_stop, series.index[-1])
        return earliest_start, latest_stop
    else:
        raise ValueError(f&#34;invalid bound method string passed {bound_method}&#34;)


def _check_start_end_array(start_idxs: np.ndarray, end_idxs: np.ndarray):
    &#34;&#34;&#34;Check if the start and end indices are valid.

    These are valid if they are of the same length and if the start indices are smaller
    than the end indices.

    Parameters
    ----------
    start_idxs: np.ndarray
        The start indices.
    end_idxs: np.ndarray
        The end indices.
    &#34;&#34;&#34;
    assert len(start_idxs) == len(
        end_idxs
    ), &#34;start_idxs and end_ixs must have equal length&#34;
    assert np.all(
        start_idxs &lt;= end_idxs
    ), &#34;for all corresponding values: segment_start_idxs &lt;= segment_end_idxs&#34;


def _get_funcwrapper_func_and_kwargs(func: FuncWrapper) -&gt; Tuple[Callable, dict]:
    &#34;&#34;&#34;Extract the function and keyword arguments from the given FuncWrapper.

    Parameters
    ----------
    func: FuncWrapper
        The FuncWrapper to extract the function and kwargs from.

    Returns
    -------
    Tuple[Callable, dict]
        Tuple of 1st the function of the FuncWrapper (is a Callable) and 2nd the keyword
        arguments of the FuncWrapper.

    &#34;&#34;&#34;
    assert isinstance(func, FuncWrapper)

    # Extract the function (is a Callable)
    function = func.func

    # Extract the keyword arguments
    func_wrapper_kwargs = dict()
    func_wrapper_kwargs[&#34;output_names&#34;] = func.output_names
    func_wrapper_kwargs[&#34;input_type&#34;] = func.input_type
    func_wrapper_kwargs[&#34;vectorized&#34;] = func.vectorized
    func_wrapper_kwargs.update(func.kwargs)

    return function, func_wrapper_kwargs


def _make_single_func_robust(
    func: Union[Callable, FuncWrapper],
    min_nb_samples: int,
    error_val: Any,
    passthrough_nans: bool,
) -&gt; FuncWrapper:
    &#34;&#34;&#34;Decorate a single`func` into a robust FuncWrapper.

    Parameters
    ----------
    func: Union[Callable, FuncWrapper]
        The function that should be made robust.
    min_nb_samples: int
        The minimum number of samples that are needed for `func` to be applied
        successfully.
    error_val: Any
        The error *return* value if the `min_nb_samples` requirement is not met.
    passthrough_nans: bool
        If set to true, `np.NaN` values, which occur in the data will be passed through.
        Otherwise, the `np.NaN` values will be masked out before being passed to `func`.

    Returns
    -------
    FuncWrapper
        The robust FuncWrapper.

    &#34;&#34;&#34;
    assert isinstance(func, FuncWrapper) or isinstance(func, Callable)

    func_wrapper_kwargs = {}
    if isinstance(func, FuncWrapper):
        # Extract the function and keyword arguments from the function wrapper
        func, func_wrapper_kwargs = _get_funcwrapper_func_and_kwargs(func)

    output_names = func_wrapper_kwargs.get(&#34;output_names&#34;)

    def wrap_func(*series: Union[np.ndarray, pd.Series], **kwargs) -&gt; Callable:
        if not passthrough_nans:
            series = [s[~np.isnan(s)] for s in series]
        if any([len(s) &lt; min_nb_samples for s in series]):
            if not isinstance(output_names, list) or len(output_names) == 1:
                return error_val
            return tuple([error_val] * len(output_names))
        return func(*series, **kwargs)

    wrap_func.__name__ = &#34;[robust]__&#34; + _get_name(func)
    if &#34;output_names&#34; not in func_wrapper_kwargs.keys():
        func_wrapper_kwargs[&#34;output_names&#34;] = _get_name(func)

    return FuncWrapper(wrap_func, **func_wrapper_kwargs)


# ---------------------------------- PUBLIC METHODS -----------------------------------
def make_robust(
    funcs: Union[Callable, FuncWrapper, List[Union[Callable, FuncWrapper]]],
    min_nb_samples: Optional[int] = 1,
    error_val: Optional[Any] = np.nan,
    passthrough_nans: Optional[bool] = True,
) -&gt; Union[FuncWrapper, List[FuncWrapper]]:
    &#34;&#34;&#34;Decorate `funcs` into one or multiple robust FuncWrappers.

     More specifically this method does (in the following order):\n
     * `np.NaN` data input propagation / filtering
     *  `min_nb_samples` checking before feeding to `func`
        (if not met, returns `error_val`)\n
     Note: this wrapper is useful for functions that should be robust for empty or
     sparse windows and/or nans in the data.

    Parameters
    ----------
    funcs: Union[Callable, FuncWrapper, List[Union[Callable, FuncWrapper]]]
        The function which will be made robust.
    min_nb_samples: int, optional
        The minimum number of samples that are needed for `func` to be applied
        successfully, by default 1.
        .. Note::
            The number of samples are determined after the `passthrough_nans` filter
            took place.

    error_val: Any, optional
        The error *return* value if the `min_nb_samples` requirement is not met, by
        default `np.NaN`.
    passthrough_nans: bool, optional
        If set to true, `np.NaN` values, which occur in the data will be passed through.
        Otherwise, the `np.NaN` values will be masked out before being passed to `func`,
        by default True.

    Returns
    -------
    Union[FuncWrapper, List[FuncWrapper]]
        The robust FuncWrapper if a single func is passed or a list of robust
        FuncWrappers when a list of functions is passed.

    &#34;&#34;&#34;
    if isinstance(funcs, Callable) or isinstance(funcs, FuncWrapper):
        return _make_single_func_robust(
            funcs, min_nb_samples, error_val, passthrough_nans
        )
    return [
        _make_single_func_robust(func, min_nb_samples, error_val, passthrough_nans)
        for func in funcs
    ]</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="tsflex.features.utils.make_robust"><code class="name flex">
<span>def <span class="ident">make_robust</span></span>(<span>funcs, min_nb_samples=1, error_val=nan, passthrough_nans=True)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_robust(
    funcs: Union[Callable, FuncWrapper, List[Union[Callable, FuncWrapper]]],
    min_nb_samples: Optional[int] = 1,
    error_val: Optional[Any] = np.nan,
    passthrough_nans: Optional[bool] = True,
) -&gt; Union[FuncWrapper, List[FuncWrapper]]:
    &#34;&#34;&#34;Decorate `funcs` into one or multiple robust FuncWrappers.

     More specifically this method does (in the following order):\n
     * `np.NaN` data input propagation / filtering
     *  `min_nb_samples` checking before feeding to `func`
        (if not met, returns `error_val`)\n
     Note: this wrapper is useful for functions that should be robust for empty or
     sparse windows and/or nans in the data.

    Parameters
    ----------
    funcs: Union[Callable, FuncWrapper, List[Union[Callable, FuncWrapper]]]
        The function which will be made robust.
    min_nb_samples: int, optional
        The minimum number of samples that are needed for `func` to be applied
        successfully, by default 1.
        .. Note::
            The number of samples are determined after the `passthrough_nans` filter
            took place.

    error_val: Any, optional
        The error *return* value if the `min_nb_samples` requirement is not met, by
        default `np.NaN`.
    passthrough_nans: bool, optional
        If set to true, `np.NaN` values, which occur in the data will be passed through.
        Otherwise, the `np.NaN` values will be masked out before being passed to `func`,
        by default True.

    Returns
    -------
    Union[FuncWrapper, List[FuncWrapper]]
        The robust FuncWrapper if a single func is passed or a list of robust
        FuncWrappers when a list of functions is passed.

    &#34;&#34;&#34;
    if isinstance(funcs, Callable) or isinstance(funcs, FuncWrapper):
        return _make_single_func_robust(
            funcs, min_nb_samples, error_val, passthrough_nans
        )
    return [
        _make_single_func_robust(func, min_nb_samples, error_val, passthrough_nans)
        for func in funcs
    ]</code></pre>
</details>
<div class="desc"><p>Decorate <code>funcs</code> into one or multiple robust FuncWrappers.</p>
<p>More specifically this method does (in the following order):</p>
<ul>
<li><code>np.NaN</code> data input propagation / filtering</li>
<li><code>min_nb_samples</code> checking before feeding to <code>func</code>
(if not met, returns <code>error_val</code>)</li>
</ul>
<p>Note: this wrapper is useful for functions that should be robust for empty or
sparse windows and/or nans in the data.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>funcs</code></strong> :&ensp;<code>Union[Callable, FuncWrapper, List[Union[Callable, FuncWrapper]]]</code></dt>
<dd>The function which will be made robust.</dd>
<dt><strong><code>min_nb_samples</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The minimum number of samples that are needed for <code>func</code> to be applied
successfully, by default 1.<div class="admonition note">
<p class="admonition-title">Note</p>
The number of samples are determined after the <code>passthrough_nans</code> filter
took place.</div>
</dd>
<dt><strong><code>error_val</code></strong> :&ensp;<code>Any</code>, optional</dt>
<dd>The error <em>return</em> value if the <code>min_nb_samples</code> requirement is not met, by
default <code>np.NaN</code>.</dd>
<dt><strong><code>passthrough_nans</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If set to true, <code>np.NaN</code> values, which occur in the data will be passed through.
Otherwise, the <code>np.NaN</code> values will be masked out before being passed to <code>func</code>,
by default True.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Union[FuncWrapper, List[FuncWrapper]]</code></dt>
<dd>The robust FuncWrapper if a single func is passed or a list of robust
FuncWrappers when a list of functions is passed.</dd>
</dl></div>
</dd>
</dl>
</section>
<section>
</section>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</article>
<div class="sidebar_container">
<nav id="sidebar">
<div id="sidebar_content">
<header>
<div style="text-align: left; padding-top: 15px;">
<a class="homelink" rel="home" title="tsflex home" href="/tsflex/">
<img src="https://raw.githubusercontent.com/predict-idlab/tsflex/main/docs/_static/logo.png"
alt="logo should be displayed here" width="95%"></a>
</div>
</header>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="tsflex.features" href="index.html">.features</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="tsflex.features.utils.make_robust" href="#tsflex.features.utils.make_robust">make_robust</a></code></li>
</ul>
</li>
</ul>
</div>
</nav>
</div>
</main>
<script>
const sidebar = document.querySelector("body > main > div");
const sidebar_nav = document.querySelector("body > main > div > nav");
const sidebar_content = document.getElementById("sidebar_content");
document.getElementById("index_button_button").onclick = function () {
sidebar.classList.toggle('sidebar_small');
sidebar_nav.classList.toggle('hide_content');
sidebar_content.classList.toggle('hide_content');
}
</script>
</body>
</html>