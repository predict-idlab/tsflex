<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>tsflex.features.feature API documentation</title>
<meta name="description" content="FeatureDescriptor and MultipleFeatureDescriptors class for creating time-series
features." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/foundation.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em;padding-left:1em;padding-right:1em}button{display:none}#sidebar{padding:3px;max-width:20em;overflow:hidden;min-width:19.8em}#sidebar > *:last-child{margin-bottom:1cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;border-top:1px solid #ddd;text-align:right}#footer p{}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f1f3f9;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:0.5em;padding:0px}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;max_width:100%;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.info{background:#edfcf4}.admonition.note,.admonition.important{background:#ebf3ff}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#edfcf4}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#ffddcc}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:850px){.sidebar_container{display:flex;transition:0.75s ease}.sidebar_small{width:0;margin:0;padding:0}.hide_content{display:none}button{display:initial;float:left;position:sticky;border:none;height:5ch;width:5ch;border-radius:50%;box-shadow:0px 1px 4px 1px rgba(0,0,0,.2);top:5%;left:100%;transform:translateX(-50%);cursor:pointer}#sidebar{width:25%;height:100vh;overflow:auto;position:sticky;top:0;transition:0.75s ease}#index_button_img{opacity:0.65}#content{max-width:105ch;padding:2em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1em;padding-right:0.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-212611910-1"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-212611910-1');
</script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
<link rel="icon" href="https://media.discordapp.net/attachments/372491075153166338/852906324417445908/icon.png">
</head>
<body>
<main>
<article id="content">
<button id="index_button_button"><img id="index_button_img"
src="https://image.flaticon.com/icons/png/512/56/56763.png"
alt="" width="33" height="25"></button>
<header>
<h1 class="title">Module <code>tsflex.features.feature</code></h1>
</header>
<section id="section-intro">
<p>FeatureDescriptor and MultipleFeatureDescriptors class for creating time-series
features.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;

FeatureDescriptor and MultipleFeatureDescriptors class for creating time-series
features.

&#34;&#34;&#34;

import itertools
from typing import Callable, List, Optional, Tuple, Union

import pandas as pd

from ..utils.argument_parsing import parse_time_arg
from ..utils.attribute_parsing import AttributeParser, DataType
from ..utils.classes import FrozenClass
from ..utils.data import to_list, to_tuple
from .function_wrapper import FuncWrapper


class FeatureDescriptor(FrozenClass):
    &#34;&#34;&#34;A FeatureDescriptor object, containing all feature information.

    Parameters
    ----------
    function : Union[FuncWrapper, Callable]
        The function that calculates the feature(s).
        The prototype of the function should match: \n

            function(*series: Union[np.array, pd.Series])
                -&gt; Union[Any, List[Any]]

        Note that when the input type is ``pd.Series``, the function should be wrapped
          in a `FuncWrapper` with `input_type` = ``pd.Series``.

    series_name : Union[str, Tuple[str, ...]]
        The names of the series on which the feature function should be applied.
        This argument should match the `function` its input; \n
        * If `series_name` is a string (or tuple of a single string), then
            `function` should require just one series as input.
        * If `series_name` is a tuple of strings, then `function` should
            require `len(tuple)` series as input **and in exactly the same order**

    window : Union[float, str, pd.Timedelta], optional
        The window size. By default None. This argument supports multiple types: \n
        * If None, the `segment_start_idxs` and `segment_end_idxs` will need to be
          passed.
        * If the type is an `float` or an `int`, its value represents the series
            - its window **range** when a **non time-indexed** series is passed.
            - its window in **number of samples**, when a **time-indexed** series is
              passed (must then be and `int`)
        * If the window&#39;s type is a `pd.Timedelta`, the window size represents
          the window-time-range. The passed data **must have a time-index**.
        * If a `str`, it must represents a window-time-range-string. The **passed data
          must have a time-index**.
        .. Note::
            - When the `segment_start_idxs` and `segment_end_idxs` are both passed to
              the `FeatureCollection.calculate` method, this window argument is ignored.
              Note that this is the only case when it is allowed to pass None for the
              window argument.
            - When the window argument is None, than the stride argument should be None
              as well (as it makes no sense to pass a stride value when the window is
              None).

    stride : Union[float, str, pd.Timedelta, List[Union[float, str, pd.Timedelta]]], optional
        The stride size(s). By default None. This argument supports multiple types: \n
        * If None, the stride will need to be passed to `FeatureCollection.calculate`.
        * If the type is an `float` or an `int`, its value represents the series
            - its stride **range** when a **non time-indexed** series is passed.
            - the stride in **number of samples**, when a **time-indexed** series
              is passed (must then be and `int`)
        * If the stride&#39;s type is a `pd.Timedelta`, the stride size represents
          the stride-time delta. The passed data **must have a time-index**.
        * If a `str`, it must represent a stride-time-delta-string. The **passed data
          must have a time-index**. \n
        * If a `List[Union[float, str, pd.Timedelta]]`, then the set intersection,of the
          strides will be used (e.g., stride=[2,3] -&gt; index: 0, 2, 3, 4, 6, 8, 9, ...)
        .. Note::
            - The stride argument of `FeatureCollection.calculate` takes precedence over
              this value when set (i.e., not None value for `stride` passed to the
              `calculate` method).
            - The stride argument should be None when the window argument is None (as it
              makes no sense to pass a stride value when the window is None).

    .. Note::
        As described above, the `window-stride` argument can be sample-based (when using
        time-index series and int based arguments), but we
        do **not encourage** using this for `time-indexed` sequences. As we make the
        implicit assumption that the time-based data is sampled at a fixed frequency
        So only, if you&#39;re 100% sure that this is correct, you can safely use such
        arguments.

    Notes
    -----
    * The `window` and `stride` argument should be either **both** numeric or
      ``pd.Timedelta`` (depending on de index datatype) - when `stride` is not None.
    * For each `function` - `input`(-series) - `window` - stride combination, one needs
      to create a distinct `FeatureDescriptor`. Hence it is more convenient to
      create a `MultipleFeatureDescriptors` when `function` - `window` - `stride`
      **combinations** should be applied on various input-series (combinations).
    * When `function` takes **multiple series** (i.e., arguments) as **input**, these
      are joined (based on the index) before applying the function. If the indexes of
      these series are not exactly the same, it might occur that not all series have
      exactly the same length! Hence,  make sure that the `function` can deal with
      this!
    * For more information about the str-based time args, look into:
      [pandas time delta](https://pandas.pydata.org/pandas-docs/stable/user_guide/timedeltas.html#parsing){:target=&#34;_blank&#34;}

    Raises
    ------
    TypeError
        * Raised when the `function` is not an instance of Callable or FuncWrapper.
        * Raised when `window` and `stride` are not of exactly the same type (when
          `stride` is not None).

    See Also
    --------
    StridedRolling: As the window-stride sequence conversion takes place there.

    &#34;&#34;&#34;

    def __init__(
        self,
        function: Union[FuncWrapper, Callable],
        series_name: Union[str, Tuple[str, ...]],
        window: Optional[Union[float, str, pd.Timedelta]] = None,
        stride: Optional[
            Union[float, str, pd.Timedelta, List[Union[float, str, pd.Timedelta]]]
        ] = None,
    ):
        strides = sorted(set(to_list(stride)))  # omit duplicate stride values
        if window is None:
            assert strides == [None], &#34;stride must be None if window is None&#34;
        self.series_name: Tuple[str, ...] = to_tuple(series_name)
        self.window = parse_time_arg(window) if isinstance(window, str) else window
        if strides == [None]:
            self.stride = None
        else:
            self.stride = [
                parse_time_arg(s) if isinstance(s, str) else s for s in strides
            ]

        # Verify whether window and stride are either both sequence or time based
        dtype_set = set(
            AttributeParser.determine_type(v)
            for v in [self.window] + to_list(self.stride)
        ).difference([DataType.UNDEFINED])
        if len(dtype_set) &gt; 1:
            raise TypeError(
                f&#34;a combination of window ({self.window} type={type(self.window)}) and&#34;
                f&#34; stride ({self.stride}) is not supported!&#34;
            )

        # Order of if statements is important (as FuncWrapper also is a Callable)!
        if isinstance(function, FuncWrapper):
            self.function: FuncWrapper = function
        elif isinstance(function, Callable):  # type: ignore[arg-type]
            self.function: FuncWrapper = FuncWrapper(function)  # type: ignore[no-redef]
        else:
            raise TypeError(
                &#34;Expected feature function to be `Callable` or `FuncWrapper` but is a&#34;
                f&#34; {type(function)}.&#34;
            )

        # Construct a function-string
        f_name = str(self.function)
        self._func_str: str = f&#34;{self.__class__.__name__} - func: {f_name}&#34;

        self._freeze()

    def get_required_series(self) -&gt; List[str]:
        &#34;&#34;&#34;Return all required series names for this feature descriptor.

        Return the list of series names that are required in order to execute the
        feature function.

        Returns
        -------
        List[str]
            List of all the required series names.

        &#34;&#34;&#34;
        return list(set(self.series_name))

    def get_nb_output_features(self) -&gt; int:
        &#34;&#34;&#34;Return the number of output features of this feature descriptor.

        Returns
        -------
        int
            Number of output features.

        &#34;&#34;&#34;
        return len(self.function.output_names)

    def __repr__(self) -&gt; str:
        &#34;&#34;&#34;Representation string of Feature.&#34;&#34;&#34;
        return (
            f&#34;{self.__class__.__name__}({self.series_name}, {self.window}, &#34;
            f&#34;{self.stride})&#34;
        )


class MultipleFeatureDescriptors:
    &#34;&#34;&#34;Create a MultipleFeatureDescriptors object.

    Create a list of features from **all** combinations of the given parameter
    lists. Total number of created `FeatureDescriptor`s will be:

        len(func_inputs)*len(functions)*len(windows)*len(strides).

    Parameters
    ----------
    functions : Union[FuncWrapper, Callable, List[Union[FuncWrapper, Callable]]]
        The functions, can be either of both types (even in a single array).
    series_names : Union[str, Tuple[str, ...], List[str], List[Tuple[str, ...]]]
        The names of the series on which the feature function should be applied.

        * If `series_names` is a (list of) string (or tuple of a single string),
          then each `function` should require just one series as input.
        * If `series_names` is a (list of) tuple of strings, then each `function` should
          require `len(tuple)` series as input.

        A `list` implies that multiple multiple series (combinations) will be used to
        extract features from; \n
        * If `series_names` is a string or a tuple of strings, then `function` will
          be called only once for the series of this argument.
        * If `series_names` is a list of either strings or tuple of strings, then
          `function` will be called for each entry of this list.

        .. Note::
            when passing a list as `series_names`, all items in this list should
            have the same type, i.e, either \n
            * all a str
            * or, all a tuple _with same length_.\n
            And perfectly match the func-input size.

    windows : Union[float, str, pd.Timedelta, List[Union[float, str, pd.Timedelta]]]
        All the window sizes.
    strides : Union[float, str, pd.Timedelta, None, List[Union[float, str, pd.Timedelta]]], optional
        All the strides. By default None.

    Note
    ----
    The `windows` and `strides` argument should be either both numeric or
    ``pd.Timedelta`` (depending on de index datatype) - when `strides` is not None.

    &#34;&#34;&#34;

    def __init__(
        self,
        functions: Union[FuncWrapper, Callable, List[Union[FuncWrapper, Callable]]],
        series_names: Union[str, Tuple[str, ...], List[str], List[Tuple[str, ...]]],
        windows: Optional[
            Union[float, str, pd.Timedelta, List[Union[float, str, pd.Timedelta]]]
        ] = None,
        strides: Optional[
            Union[float, str, pd.Timedelta, List[Union[float, str, pd.Timedelta]]]
        ] = None,
    ):
        # Cast functions to FuncWrapper, this avoids creating multiple
        # FuncWrapper objects for the same function in the FeatureDescriptor
        def to_func_wrapper(f: Callable) -&gt; FuncWrapper:
            return f if isinstance(f, FuncWrapper) else FuncWrapper(f)

        functions = [to_func_wrapper(f) for f in to_list(functions)]
        # Convert the series names to list of tuples
        series_names = [to_tuple(names) for names in to_list(series_names)]
        # Assert that function inputs (series) all have the same length
        assert all(
            len(series_names[0]) == len(series_name_tuple)
            for series_name_tuple in series_names
        )
        # Convert the other types to list
        windows = to_list(windows)

        self.feature_descriptions: List[FeatureDescriptor] = []
        # Iterate over all combinations
        combinations = [functions, series_names, windows]
        for function, series_name, window in itertools.product(*combinations):  # type: ignore[call-overload]
            self.feature_descriptions.append(
                FeatureDescriptor(function, series_name, window, strides)
            )</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="tsflex.features.feature.FeatureDescriptor"><code class="flex name class">
<span>class <span class="ident">FeatureDescriptor</span></span>
<span>(</span><span>function, series_name, window=None, stride=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FeatureDescriptor(FrozenClass):
    &#34;&#34;&#34;A FeatureDescriptor object, containing all feature information.

    Parameters
    ----------
    function : Union[FuncWrapper, Callable]
        The function that calculates the feature(s).
        The prototype of the function should match: \n

            function(*series: Union[np.array, pd.Series])
                -&gt; Union[Any, List[Any]]

        Note that when the input type is ``pd.Series``, the function should be wrapped
          in a `FuncWrapper` with `input_type` = ``pd.Series``.

    series_name : Union[str, Tuple[str, ...]]
        The names of the series on which the feature function should be applied.
        This argument should match the `function` its input; \n
        * If `series_name` is a string (or tuple of a single string), then
            `function` should require just one series as input.
        * If `series_name` is a tuple of strings, then `function` should
            require `len(tuple)` series as input **and in exactly the same order**

    window : Union[float, str, pd.Timedelta], optional
        The window size. By default None. This argument supports multiple types: \n
        * If None, the `segment_start_idxs` and `segment_end_idxs` will need to be
          passed.
        * If the type is an `float` or an `int`, its value represents the series
            - its window **range** when a **non time-indexed** series is passed.
            - its window in **number of samples**, when a **time-indexed** series is
              passed (must then be and `int`)
        * If the window&#39;s type is a `pd.Timedelta`, the window size represents
          the window-time-range. The passed data **must have a time-index**.
        * If a `str`, it must represents a window-time-range-string. The **passed data
          must have a time-index**.
        .. Note::
            - When the `segment_start_idxs` and `segment_end_idxs` are both passed to
              the `FeatureCollection.calculate` method, this window argument is ignored.
              Note that this is the only case when it is allowed to pass None for the
              window argument.
            - When the window argument is None, than the stride argument should be None
              as well (as it makes no sense to pass a stride value when the window is
              None).

    stride : Union[float, str, pd.Timedelta, List[Union[float, str, pd.Timedelta]]], optional
        The stride size(s). By default None. This argument supports multiple types: \n
        * If None, the stride will need to be passed to `FeatureCollection.calculate`.
        * If the type is an `float` or an `int`, its value represents the series
            - its stride **range** when a **non time-indexed** series is passed.
            - the stride in **number of samples**, when a **time-indexed** series
              is passed (must then be and `int`)
        * If the stride&#39;s type is a `pd.Timedelta`, the stride size represents
          the stride-time delta. The passed data **must have a time-index**.
        * If a `str`, it must represent a stride-time-delta-string. The **passed data
          must have a time-index**. \n
        * If a `List[Union[float, str, pd.Timedelta]]`, then the set intersection,of the
          strides will be used (e.g., stride=[2,3] -&gt; index: 0, 2, 3, 4, 6, 8, 9, ...)
        .. Note::
            - The stride argument of `FeatureCollection.calculate` takes precedence over
              this value when set (i.e., not None value for `stride` passed to the
              `calculate` method).
            - The stride argument should be None when the window argument is None (as it
              makes no sense to pass a stride value when the window is None).

    .. Note::
        As described above, the `window-stride` argument can be sample-based (when using
        time-index series and int based arguments), but we
        do **not encourage** using this for `time-indexed` sequences. As we make the
        implicit assumption that the time-based data is sampled at a fixed frequency
        So only, if you&#39;re 100% sure that this is correct, you can safely use such
        arguments.

    Notes
    -----
    * The `window` and `stride` argument should be either **both** numeric or
      ``pd.Timedelta`` (depending on de index datatype) - when `stride` is not None.
    * For each `function` - `input`(-series) - `window` - stride combination, one needs
      to create a distinct `FeatureDescriptor`. Hence it is more convenient to
      create a `MultipleFeatureDescriptors` when `function` - `window` - `stride`
      **combinations** should be applied on various input-series (combinations).
    * When `function` takes **multiple series** (i.e., arguments) as **input**, these
      are joined (based on the index) before applying the function. If the indexes of
      these series are not exactly the same, it might occur that not all series have
      exactly the same length! Hence,  make sure that the `function` can deal with
      this!
    * For more information about the str-based time args, look into:
      [pandas time delta](https://pandas.pydata.org/pandas-docs/stable/user_guide/timedeltas.html#parsing){:target=&#34;_blank&#34;}

    Raises
    ------
    TypeError
        * Raised when the `function` is not an instance of Callable or FuncWrapper.
        * Raised when `window` and `stride` are not of exactly the same type (when
          `stride` is not None).

    See Also
    --------
    StridedRolling: As the window-stride sequence conversion takes place there.

    &#34;&#34;&#34;

    def __init__(
        self,
        function: Union[FuncWrapper, Callable],
        series_name: Union[str, Tuple[str, ...]],
        window: Optional[Union[float, str, pd.Timedelta]] = None,
        stride: Optional[
            Union[float, str, pd.Timedelta, List[Union[float, str, pd.Timedelta]]]
        ] = None,
    ):
        strides = sorted(set(to_list(stride)))  # omit duplicate stride values
        if window is None:
            assert strides == [None], &#34;stride must be None if window is None&#34;
        self.series_name: Tuple[str, ...] = to_tuple(series_name)
        self.window = parse_time_arg(window) if isinstance(window, str) else window
        if strides == [None]:
            self.stride = None
        else:
            self.stride = [
                parse_time_arg(s) if isinstance(s, str) else s for s in strides
            ]

        # Verify whether window and stride are either both sequence or time based
        dtype_set = set(
            AttributeParser.determine_type(v)
            for v in [self.window] + to_list(self.stride)
        ).difference([DataType.UNDEFINED])
        if len(dtype_set) &gt; 1:
            raise TypeError(
                f&#34;a combination of window ({self.window} type={type(self.window)}) and&#34;
                f&#34; stride ({self.stride}) is not supported!&#34;
            )

        # Order of if statements is important (as FuncWrapper also is a Callable)!
        if isinstance(function, FuncWrapper):
            self.function: FuncWrapper = function
        elif isinstance(function, Callable):  # type: ignore[arg-type]
            self.function: FuncWrapper = FuncWrapper(function)  # type: ignore[no-redef]
        else:
            raise TypeError(
                &#34;Expected feature function to be `Callable` or `FuncWrapper` but is a&#34;
                f&#34; {type(function)}.&#34;
            )

        # Construct a function-string
        f_name = str(self.function)
        self._func_str: str = f&#34;{self.__class__.__name__} - func: {f_name}&#34;

        self._freeze()

    def get_required_series(self) -&gt; List[str]:
        &#34;&#34;&#34;Return all required series names for this feature descriptor.

        Return the list of series names that are required in order to execute the
        feature function.

        Returns
        -------
        List[str]
            List of all the required series names.

        &#34;&#34;&#34;
        return list(set(self.series_name))

    def get_nb_output_features(self) -&gt; int:
        &#34;&#34;&#34;Return the number of output features of this feature descriptor.

        Returns
        -------
        int
            Number of output features.

        &#34;&#34;&#34;
        return len(self.function.output_names)

    def __repr__(self) -&gt; str:
        &#34;&#34;&#34;Representation string of Feature.&#34;&#34;&#34;
        return (
            f&#34;{self.__class__.__name__}({self.series_name}, {self.window}, &#34;
            f&#34;{self.stride})&#34;
        )</code></pre>
</details>
<div class="desc"><p>A FeatureDescriptor object, containing all feature information.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>function</code></strong> :&ensp;<code>Union[FuncWrapper, Callable]</code></dt>
<dd>
<p>The function that calculates the feature(s).
The prototype of the function should match: </p>
<pre><code>function(*series: Union[np.array, pd.Series])
    -&gt; Union[Any, List[Any]]
</code></pre>
<p>Note that when the input type is <code>pd.Series</code>, the function should be wrapped
in a <code>FuncWrapper</code> with <code>input_type</code> = <code>pd.Series</code>.</p>
</dd>
<dt><strong><code>series_name</code></strong> :&ensp;<code>Union[str, Tuple[str, &hellip;]]</code></dt>
<dd>
<p>The names of the series on which the feature function should be applied.
This argument should match the <code>function</code> its input; </p>
<ul>
<li>If <code>series_name</code> is a string (or tuple of a single string), then
<code>function</code> should require just one series as input.</li>
<li>If <code>series_name</code> is a tuple of strings, then <code>function</code> should
require <code>len(tuple)</code> series as input <strong>and in exactly the same order</strong></li>
</ul>
</dd>
<dt><strong><code>window</code></strong> :&ensp;<code>Union[float, str, pd.Timedelta]</code>, optional</dt>
<dd>
<p>The window size. By default None. This argument supports multiple types: </p>
<ul>
<li>If None, the <code>segment_start_idxs</code> and <code>segment_end_idxs</code> will need to be
passed.</li>
<li>If the type is an <code>float</code> or an <code>int</code>, its value represents the series<ul>
<li>its window <strong>range</strong> when a <strong>non time-indexed</strong> series is passed.</li>
<li>its window in <strong>number of samples</strong>, when a <strong>time-indexed</strong> series is
passed (must then be and <code>int</code>)</li>
</ul>
</li>
<li>If the window's type is a <code>pd.Timedelta</code>, the window size represents
the window-time-range. The passed data <strong>must have a time-index</strong>.</li>
<li>If a <code>str</code>, it must represents a window-time-range-string. The <strong>passed data
must have a time-index</strong>.</li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ul>
<li>When the <code>segment_start_idxs</code> and <code>segment_end_idxs</code> are both passed to
the <code>FeatureCollection.calculate</code> method, this window argument is ignored.
Note that this is the only case when it is allowed to pass None for the
window argument.</li>
<li>When the window argument is None, than the stride argument should be None
as well (as it makes no sense to pass a stride value when the window is
None).</li>
</ul>
</div>
</dd>
<dt><strong><code>stride</code></strong> :&ensp;<code>Union[float, str, pd.Timedelta, List[Union[float, str, pd.Timedelta]]]</code>, optional</dt>
<dd>
<p>The stride size(s). By default None. This argument supports multiple types: </p>
<ul>
<li>If None, the stride will need to be passed to <code>FeatureCollection.calculate</code>.</li>
<li>If the type is an <code>float</code> or an <code>int</code>, its value represents the series<ul>
<li>its stride <strong>range</strong> when a <strong>non time-indexed</strong> series is passed.</li>
<li>the stride in <strong>number of samples</strong>, when a <strong>time-indexed</strong> series
is passed (must then be and <code>int</code>)</li>
</ul>
</li>
<li>If the stride's type is a <code>pd.Timedelta</code>, the stride size represents
the stride-time delta. The passed data <strong>must have a time-index</strong>.</li>
<li>
<p>If a <code>str</code>, it must represent a stride-time-delta-string. The <strong>passed data
must have a time-index</strong>. </p>
</li>
<li>
<p>If a <code>List[Union[float, str, pd.Timedelta]]</code>, then the set intersection,of the
strides will be used (e.g., stride=[2,3] -&gt; index: 0, 2, 3, 4, 6, 8, 9, &hellip;)</p>
</li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ul>
<li>The stride argument of <code>FeatureCollection.calculate</code> takes precedence over
this value when set (i.e., not None value for <code>stride</code> passed to the
<code>calculate</code> method).</li>
<li>The stride argument should be None when the window argument is None (as it
makes no sense to pass a stride value when the window is None).</li>
</ul>
</div>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>As described above, the <code>window-stride</code> argument can be sample-based (when using
time-index series and int based arguments), but we
do <strong>not encourage</strong> using this for <code>time-indexed</code> sequences. As we make the
implicit assumption that the time-based data is sampled at a fixed frequency
So only, if you're 100% sure that this is correct, you can safely use such
arguments.</p>
</div>
<h2 id="notes">Notes</h2>
<ul>
<li>The <code>window</code> and <code>stride</code> argument should be either <strong>both</strong> numeric or
<code>pd.Timedelta</code> (depending on de index datatype) - when <code>stride</code> is not None.</li>
<li>For each <code>function</code> - <code>input</code>(-series) - <code>window</code> - stride combination, one needs
to create a distinct <code><a title="tsflex.features.feature.FeatureDescriptor" href="#tsflex.features.feature.FeatureDescriptor">FeatureDescriptor</a></code>. Hence it is more convenient to
create a <code><a title="tsflex.features.feature.MultipleFeatureDescriptors" href="#tsflex.features.feature.MultipleFeatureDescriptors">MultipleFeatureDescriptors</a></code> when <code>function</code> - <code>window</code> - <code>stride</code>
<strong>combinations</strong> should be applied on various input-series (combinations).</li>
<li>When <code>function</code> takes <strong>multiple series</strong> (i.e., arguments) as <strong>input</strong>, these
are joined (based on the index) before applying the function. If the indexes of
these series are not exactly the same, it might occur that not all series have
exactly the same length! Hence,
make sure that the <code>function</code> can deal with
this!</li>
<li>For more information about the str-based time args, look into:
<a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/timedeltas.html#parsing" target="_blank">pandas time delta</a></li>
</ul>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>
<ul>
<li>Raised when the <code>function</code> is not an instance of Callable or FuncWrapper.</li>
<li>Raised when <code>window</code> and <code>stride</code> are not of exactly the same type (when
<code>stride</code> is not None).</li>
</ul>
</dd>
</dl>
<h2 id="see-also">See Also</h2>
<dl>
<dt><code>StridedRolling</code></dt>
<dd>As the window-stride sequence conversion takes place there.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>tsflex.utils.classes.FrozenClass</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="tsflex.features.feature.FeatureDescriptor.get_required_series"><code class="name flex">
<span>def <span class="ident">get_required_series</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_required_series(self) -&gt; List[str]:
    &#34;&#34;&#34;Return all required series names for this feature descriptor.

    Return the list of series names that are required in order to execute the
    feature function.

    Returns
    -------
    List[str]
        List of all the required series names.

    &#34;&#34;&#34;
    return list(set(self.series_name))</code></pre>
</details>
<div class="desc"><p>Return all required series names for this feature descriptor.</p>
<p>Return the list of series names that are required in order to execute the
feature function.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List[str]</code></dt>
<dd>List of all the required series names.</dd>
</dl></div>
</dd>
<dt id="tsflex.features.feature.FeatureDescriptor.get_nb_output_features"><code class="name flex">
<span>def <span class="ident">get_nb_output_features</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_nb_output_features(self) -&gt; int:
    &#34;&#34;&#34;Return the number of output features of this feature descriptor.

    Returns
    -------
    int
        Number of output features.

    &#34;&#34;&#34;
    return len(self.function.output_names)</code></pre>
</details>
<div class="desc"><p>Return the number of output features of this feature descriptor.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>Number of output features.</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="tsflex.features.feature.MultipleFeatureDescriptors"><code class="flex name class">
<span>class <span class="ident">MultipleFeatureDescriptors</span></span>
<span>(</span><span>functions, series_names, windows=None, strides=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MultipleFeatureDescriptors:
    &#34;&#34;&#34;Create a MultipleFeatureDescriptors object.

    Create a list of features from **all** combinations of the given parameter
    lists. Total number of created `FeatureDescriptor`s will be:

        len(func_inputs)*len(functions)*len(windows)*len(strides).

    Parameters
    ----------
    functions : Union[FuncWrapper, Callable, List[Union[FuncWrapper, Callable]]]
        The functions, can be either of both types (even in a single array).
    series_names : Union[str, Tuple[str, ...], List[str], List[Tuple[str, ...]]]
        The names of the series on which the feature function should be applied.

        * If `series_names` is a (list of) string (or tuple of a single string),
          then each `function` should require just one series as input.
        * If `series_names` is a (list of) tuple of strings, then each `function` should
          require `len(tuple)` series as input.

        A `list` implies that multiple multiple series (combinations) will be used to
        extract features from; \n
        * If `series_names` is a string or a tuple of strings, then `function` will
          be called only once for the series of this argument.
        * If `series_names` is a list of either strings or tuple of strings, then
          `function` will be called for each entry of this list.

        .. Note::
            when passing a list as `series_names`, all items in this list should
            have the same type, i.e, either \n
            * all a str
            * or, all a tuple _with same length_.\n
            And perfectly match the func-input size.

    windows : Union[float, str, pd.Timedelta, List[Union[float, str, pd.Timedelta]]]
        All the window sizes.
    strides : Union[float, str, pd.Timedelta, None, List[Union[float, str, pd.Timedelta]]], optional
        All the strides. By default None.

    Note
    ----
    The `windows` and `strides` argument should be either both numeric or
    ``pd.Timedelta`` (depending on de index datatype) - when `strides` is not None.

    &#34;&#34;&#34;

    def __init__(
        self,
        functions: Union[FuncWrapper, Callable, List[Union[FuncWrapper, Callable]]],
        series_names: Union[str, Tuple[str, ...], List[str], List[Tuple[str, ...]]],
        windows: Optional[
            Union[float, str, pd.Timedelta, List[Union[float, str, pd.Timedelta]]]
        ] = None,
        strides: Optional[
            Union[float, str, pd.Timedelta, List[Union[float, str, pd.Timedelta]]]
        ] = None,
    ):
        # Cast functions to FuncWrapper, this avoids creating multiple
        # FuncWrapper objects for the same function in the FeatureDescriptor
        def to_func_wrapper(f: Callable) -&gt; FuncWrapper:
            return f if isinstance(f, FuncWrapper) else FuncWrapper(f)

        functions = [to_func_wrapper(f) for f in to_list(functions)]
        # Convert the series names to list of tuples
        series_names = [to_tuple(names) for names in to_list(series_names)]
        # Assert that function inputs (series) all have the same length
        assert all(
            len(series_names[0]) == len(series_name_tuple)
            for series_name_tuple in series_names
        )
        # Convert the other types to list
        windows = to_list(windows)

        self.feature_descriptions: List[FeatureDescriptor] = []
        # Iterate over all combinations
        combinations = [functions, series_names, windows]
        for function, series_name, window in itertools.product(*combinations):  # type: ignore[call-overload]
            self.feature_descriptions.append(
                FeatureDescriptor(function, series_name, window, strides)
            )</code></pre>
</details>
<div class="desc"><p>Create a MultipleFeatureDescriptors object.</p>
<p>Create a list of features from <strong>all</strong> combinations of the given parameter
lists. Total number of created <code><a title="tsflex.features.feature.FeatureDescriptor" href="#tsflex.features.feature.FeatureDescriptor">FeatureDescriptor</a></code>s will be:</p>
<pre><code>len(func_inputs)*len(functions)*len(windows)*len(strides).
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>functions</code></strong> :&ensp;<code>Union[FuncWrapper, Callable, List[Union[FuncWrapper, Callable]]]</code></dt>
<dd>The functions, can be either of both types (even in a single array).</dd>
<dt><strong><code>series_names</code></strong> :&ensp;<code>Union[str, Tuple[str, &hellip;], List[str], List[Tuple[str, &hellip;]]]</code></dt>
<dd>
<p>The names of the series on which the feature function should be applied.</p>
<ul>
<li>If <code>series_names</code> is a (list of) string (or tuple of a single string),
then each <code>function</code> should require just one series as input.</li>
<li>If <code>series_names</code> is a (list of) tuple of strings, then each <code>function</code> should
require <code>len(tuple)</code> series as input.</li>
</ul>
<p>A <code>list</code> implies that multiple multiple series (combinations) will be used to
extract features from; </p>
<ul>
<li>If <code>series_names</code> is a string or a tuple of strings, then <code>function</code> will
be called only once for the series of this argument.</li>
<li>If <code>series_names</code> is a list of either strings or tuple of strings, then
<code>function</code> will be called for each entry of this list.</li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>when passing a list as <code>series_names</code>, all items in this list should
have the same type, i.e, either </p>
<ul>
<li>all a str</li>
<li>or, all a tuple <em>with same length</em>.</li>
</ul>
<p>And perfectly match the func-input size.</p>
</div>
</dd>
<dt><strong><code>windows</code></strong> :&ensp;<code>Union[float, str, pd.Timedelta, List[Union[float, str, pd.Timedelta]]]</code></dt>
<dd>All the window sizes.</dd>
<dt><strong><code>strides</code></strong> :&ensp;<code>Union[float, str, pd.Timedelta, None, List[Union[float, str, pd.Timedelta]]]</code>, optional</dt>
<dd>All the strides. By default None.</dd>
</dl>
<h2 id="note">Note</h2>
<p>The <code>windows</code> and <code>strides</code> argument should be either both numeric or
<code>pd.Timedelta</code> (depending on de index datatype) - when <code>strides</code> is not None.</p></div>
</dd>
</dl>
</section>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</article>
<div class="sidebar_container">
<nav id="sidebar">
<div id="sidebar_content">
<header>
<div style="text-align: left; padding-top: 15px;">
<a class="homelink" rel="home" title="tsflex home" href="/tsflex/">
<img src="https://raw.githubusercontent.com/predict-idlab/tsflex/main/docs/_static/logo.png"
alt="logo should be displayed here" width="95%"></a>
</div>
</header>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="tsflex.features" href="index.html">.features</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="tsflex.features.feature.FeatureDescriptor" href="#tsflex.features.feature.FeatureDescriptor">FeatureDescriptor</a></code></h4>
<ul class="">
<li><code><a title="tsflex.features.feature.FeatureDescriptor.get_required_series" href="#tsflex.features.feature.FeatureDescriptor.get_required_series">get_required_series</a></code></li>
<li><code><a title="tsflex.features.feature.FeatureDescriptor.get_nb_output_features" href="#tsflex.features.feature.FeatureDescriptor.get_nb_output_features">get_nb_output_features</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tsflex.features.feature.MultipleFeatureDescriptors" href="#tsflex.features.feature.MultipleFeatureDescriptors">MultipleFeatureDescriptors</a></code></h4>
</li>
</ul>
</li>
</ul>
</div>
</nav>
</div>
</main>
<script>
const sidebar = document.querySelector("body > main > div");
const sidebar_nav = document.querySelector("body > main > div > nav");
const sidebar_content = document.getElementById("sidebar_content");
document.getElementById("index_button_button").onclick = function () {
sidebar.classList.toggle('sidebar_small');
sidebar_nav.classList.toggle('hide_content');
sidebar_content.classList.toggle('hide_content');
}
</script>
</body>
</html>